
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cast: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/lucasepe/yo/internal/cast/cast.go (92.9%)</option>
				
				<option value="file1">github.com/lucasepe/yo/internal/cast/caste.go (96.7%)</option>
				
				<option value="file2">github.com/lucasepe/yo/internal/parser/generators.go (81.5%)</option>
				
				<option value="file3">github.com/lucasepe/yo/internal/parser/lexer.go (78.7%)</option>
				
				<option value="file4">github.com/lucasepe/yo/internal/parser/parser.go (55.1%)</option>
				
				<option value="file5">github.com/lucasepe/yo/internal/parser/scanner.go (14.3%)</option>
				
				<option value="file6">github.com/lucasepe/yo/internal/parser/token.go (0.0%)</option>
				
				<option value="file7">github.com/lucasepe/yo/internal/template/crypto.go (100.0%)</option>
				
				<option value="file8">github.com/lucasepe/yo/internal/template/date.go (68.6%)</option>
				
				<option value="file9">github.com/lucasepe/yo/internal/template/defaults.go (81.5%)</option>
				
				<option value="file10">github.com/lucasepe/yo/internal/template/functions.go (44.8%)</option>
				
				<option value="file11">github.com/lucasepe/yo/internal/template/list.go (93.3%)</option>
				
				<option value="file12">github.com/lucasepe/yo/internal/template/numeric.go (97.9%)</option>
				
				<option value="file13">github.com/lucasepe/yo/internal/template/regex.go (77.3%)</option>
				
				<option value="file14">github.com/lucasepe/yo/internal/template/strings.go (89.6%)</option>
				
				<option value="file15">github.com/lucasepe/yo/internal/template/template.go (0.0%)</option>
				
				<option value="file16">github.com/lucasepe/yo/internal/wordutils/wordutils.go (87.9%)</option>
				
				<option value="file17">github.com/lucasepe/yo/internal/xstrings/common.go (73.3%)</option>
				
				<option value="file18">github.com/lucasepe/yo/internal/xstrings/convert.go (100.0%)</option>
				
				<option value="file19">github.com/lucasepe/yo/internal/xstrings/count.go (88.9%)</option>
				
				<option value="file20">github.com/lucasepe/yo/internal/xstrings/format.go (97.0%)</option>
				
				<option value="file21">github.com/lucasepe/yo/internal/xstrings/translate.go (95.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright © 2014 Steve Francia &lt;spf@spf13.com&gt;.
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file.

// Package cast provides easy and safe casting in Go.
package cast

// ToBool casts an interface to a bool type.
func ToBool(i interface{}) bool <span class="cov0" title="0">{
        v, _ := ToBoolE(i)
        return v
}</span>

// ToFloat64 casts an interface to a float64 type.
func ToFloat64(i interface{}) float64 <span class="cov8" title="15">{
        v, _ := ToFloat64E(i)
        return v
}</span>

// ToFloat32 casts an interface to a float32 type.
func ToFloat32(i interface{}) float32 <span class="cov8" title="15">{
        v, _ := ToFloat32E(i)
        return v
}</span>

// ToInt64 casts an interface to an int64 type.
func ToInt64(i interface{}) int64 <span class="cov8" title="16">{
        v, _ := ToInt64E(i)
        return v
}</span>

// ToInt32 casts an interface to an int32 type.
func ToInt32(i interface{}) int32 <span class="cov8" title="16">{
        v, _ := ToInt32E(i)
        return v
}</span>

// ToInt16 casts an interface to an int16 type.
func ToInt16(i interface{}) int16 <span class="cov8" title="16">{
        v, _ := ToInt16E(i)
        return v
}</span>

// ToInt8 casts an interface to an int8 type.
func ToInt8(i interface{}) int8 <span class="cov8" title="16">{
        v, _ := ToInt8E(i)
        return v
}</span>

// ToInt casts an interface to an int type.
func ToInt(i interface{}) int <span class="cov8" title="16">{
        v, _ := ToIntE(i)
        return v
}</span>

// ToUint casts an interface to a uint type.
func ToUint(i interface{}) uint <span class="cov8" title="16">{
        v, _ := ToUintE(i)
        return v
}</span>

// ToUint64 casts an interface to a uint64 type.
func ToUint64(i interface{}) uint64 <span class="cov8" title="16">{
        v, _ := ToUint64E(i)
        return v
}</span>

// ToUint32 casts an interface to a uint32 type.
func ToUint32(i interface{}) uint32 <span class="cov8" title="16">{
        v, _ := ToUint32E(i)
        return v
}</span>

// ToUint16 casts an interface to a uint16 type.
func ToUint16(i interface{}) uint16 <span class="cov8" title="16">{
        v, _ := ToUint16E(i)
        return v
}</span>

// ToUint8 casts an interface to a uint8 type.
func ToUint8(i interface{}) uint8 <span class="cov8" title="16">{
        v, _ := ToUint8E(i)
        return v
}</span>

// ToString casts an interface to a string type.
func ToString(i interface{}) string <span class="cov10" title="24">{
        v, _ := ToStringE(i)
        return v
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright © 2014 Steve Francia &lt;spf@spf13.com&gt;.
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file.

package cast

import (
        "errors"
        "fmt"
        "html/template"
        "reflect"
        "strconv"
)

var errNegativeNotAllowed = errors.New("unable to cast negative value")

// ToBoolE casts an interface to a bool type.
func ToBoolE(i interface{}) (bool, error) <span class="cov0" title="0">{
        i = indirect(i)

        switch b := i.(type) </span>{
        case bool:<span class="cov0" title="0">
                return b, nil</span>
        case nil:<span class="cov0" title="0">
                return false, nil</span>
        case int:<span class="cov0" title="0">
                if i.(int) != 0 </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
                <span class="cov0" title="0">return false, nil</span>
        case string:<span class="cov0" title="0">
                return strconv.ParseBool(i.(string))</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("unable to cast %#v of type %T to bool", i, i)</span>
        }
}

// ToFloat64E casts an interface to a float64 type.
func ToFloat64E(i interface{}) (float64, error) <span class="cov6" title="32">{
        i = indirect(i)

        switch s := i.(type) </span>{
        case float64:<span class="cov2" title="2">
                return s, nil</span>
        case float32:<span class="cov2" title="2">
                return float64(s), nil</span>
        case int:<span class="cov2" title="2">
                return float64(s), nil</span>
        case int64:<span class="cov2" title="2">
                return float64(s), nil</span>
        case int32:<span class="cov2" title="2">
                return float64(s), nil</span>
        case int16:<span class="cov2" title="2">
                return float64(s), nil</span>
        case int8:<span class="cov2" title="2">
                return float64(s), nil</span>
        case uint:<span class="cov2" title="2">
                return float64(s), nil</span>
        case uint64:<span class="cov2" title="2">
                return float64(s), nil</span>
        case uint32:<span class="cov2" title="2">
                return float64(s), nil</span>
        case uint16:<span class="cov2" title="2">
                return float64(s), nil</span>
        case uint8:<span class="cov2" title="2">
                return float64(s), nil</span>
        case string:<span class="cov2" title="3">
                v, err := strconv.ParseFloat(s, 64)
                if err == nil </span><span class="cov2" title="2">{
                        return v, nil
                }</span>
                <span class="cov1" title="1">return 0, fmt.Errorf("unable to cast %#v of type %T to float64", i, i)</span>
        case bool:<span class="cov3" title="4">
                if s </span><span class="cov2" title="2">{
                        return 1, nil
                }</span>
                <span class="cov2" title="2">return 0, nil</span>
        default:<span class="cov1" title="1">
                return 0, fmt.Errorf("unable to cast %#v of type %T to float64", i, i)</span>
        }
}

// ToFloat32E casts an interface to a float32 type.
func ToFloat32E(i interface{}) (float32, error) <span class="cov6" title="32">{
        i = indirect(i)

        switch s := i.(type) </span>{
        case float64:<span class="cov2" title="2">
                return float32(s), nil</span>
        case float32:<span class="cov2" title="2">
                return s, nil</span>
        case int:<span class="cov2" title="2">
                return float32(s), nil</span>
        case int64:<span class="cov2" title="2">
                return float32(s), nil</span>
        case int32:<span class="cov2" title="2">
                return float32(s), nil</span>
        case int16:<span class="cov2" title="2">
                return float32(s), nil</span>
        case int8:<span class="cov2" title="2">
                return float32(s), nil</span>
        case uint:<span class="cov2" title="2">
                return float32(s), nil</span>
        case uint64:<span class="cov2" title="2">
                return float32(s), nil</span>
        case uint32:<span class="cov2" title="2">
                return float32(s), nil</span>
        case uint16:<span class="cov2" title="2">
                return float32(s), nil</span>
        case uint8:<span class="cov2" title="2">
                return float32(s), nil</span>
        case string:<span class="cov2" title="3">
                v, err := strconv.ParseFloat(s, 32)
                if err == nil </span><span class="cov2" title="2">{
                        return float32(v), nil
                }</span>
                <span class="cov1" title="1">return 0, fmt.Errorf("unable to cast %#v of type %T to float32", i, i)</span>
        case bool:<span class="cov3" title="4">
                if s </span><span class="cov2" title="2">{
                        return 1, nil
                }</span>
                <span class="cov2" title="2">return 0, nil</span>
        default:<span class="cov1" title="1">
                return 0, fmt.Errorf("unable to cast %#v of type %T to float32", i, i)</span>
        }
}

// ToInt64E casts an interface to an int64 type.
func ToInt64E(i interface{}) (int64, error) <span class="cov6" title="34">{
        i = indirect(i)

        switch s := i.(type) </span>{
        case int:<span class="cov2" title="2">
                return int64(s), nil</span>
        case int64:<span class="cov2" title="2">
                return s, nil</span>
        case int32:<span class="cov2" title="2">
                return int64(s), nil</span>
        case int16:<span class="cov2" title="2">
                return int64(s), nil</span>
        case int8:<span class="cov2" title="2">
                return int64(s), nil</span>
        case uint:<span class="cov2" title="2">
                return int64(s), nil</span>
        case uint64:<span class="cov2" title="2">
                return int64(s), nil</span>
        case uint32:<span class="cov2" title="2">
                return int64(s), nil</span>
        case uint16:<span class="cov2" title="2">
                return int64(s), nil</span>
        case uint8:<span class="cov2" title="2">
                return int64(s), nil</span>
        case float64:<span class="cov2" title="2">
                return int64(s), nil</span>
        case float32:<span class="cov2" title="2">
                return int64(s), nil</span>
        case string:<span class="cov2" title="3">
                v, err := strconv.ParseInt(s, 0, 0)
                if err == nil </span><span class="cov2" title="2">{
                        return v, nil
                }</span>
                <span class="cov1" title="1">return 0, fmt.Errorf("unable to cast %#v of type %T to int64", i, i)</span>
        case bool:<span class="cov3" title="4">
                if s </span><span class="cov2" title="2">{
                        return 1, nil
                }</span>
                <span class="cov2" title="2">return 0, nil</span>
        case nil:<span class="cov2" title="2">
                return 0, nil</span>
        default:<span class="cov1" title="1">
                return 0, fmt.Errorf("unable to cast %#v of type %T to int64", i, i)</span>
        }
}

// ToInt32E casts an interface to an int32 type.
func ToInt32E(i interface{}) (int32, error) <span class="cov6" title="34">{
        i = indirect(i)

        switch s := i.(type) </span>{
        case int:<span class="cov2" title="2">
                return int32(s), nil</span>
        case int64:<span class="cov2" title="2">
                return int32(s), nil</span>
        case int32:<span class="cov2" title="2">
                return s, nil</span>
        case int16:<span class="cov2" title="2">
                return int32(s), nil</span>
        case int8:<span class="cov2" title="2">
                return int32(s), nil</span>
        case uint:<span class="cov2" title="2">
                return int32(s), nil</span>
        case uint64:<span class="cov2" title="2">
                return int32(s), nil</span>
        case uint32:<span class="cov2" title="2">
                return int32(s), nil</span>
        case uint16:<span class="cov2" title="2">
                return int32(s), nil</span>
        case uint8:<span class="cov2" title="2">
                return int32(s), nil</span>
        case float64:<span class="cov2" title="2">
                return int32(s), nil</span>
        case float32:<span class="cov2" title="2">
                return int32(s), nil</span>
        case string:<span class="cov2" title="3">
                v, err := strconv.ParseInt(s, 0, 0)
                if err == nil </span><span class="cov2" title="2">{
                        return int32(v), nil
                }</span>
                <span class="cov1" title="1">return 0, fmt.Errorf("unable to cast %#v of type %T to int32", i, i)</span>
        case bool:<span class="cov3" title="4">
                if s </span><span class="cov2" title="2">{
                        return 1, nil
                }</span>
                <span class="cov2" title="2">return 0, nil</span>
        case nil:<span class="cov2" title="2">
                return 0, nil</span>
        default:<span class="cov1" title="1">
                return 0, fmt.Errorf("unable to cast %#v of type %T to int32", i, i)</span>
        }
}

// ToInt16E casts an interface to an int16 type.
func ToInt16E(i interface{}) (int16, error) <span class="cov6" title="34">{
        i = indirect(i)

        switch s := i.(type) </span>{
        case int:<span class="cov2" title="2">
                return int16(s), nil</span>
        case int64:<span class="cov2" title="2">
                return int16(s), nil</span>
        case int32:<span class="cov2" title="2">
                return int16(s), nil</span>
        case int16:<span class="cov2" title="2">
                return s, nil</span>
        case int8:<span class="cov2" title="2">
                return int16(s), nil</span>
        case uint:<span class="cov2" title="2">
                return int16(s), nil</span>
        case uint64:<span class="cov2" title="2">
                return int16(s), nil</span>
        case uint32:<span class="cov2" title="2">
                return int16(s), nil</span>
        case uint16:<span class="cov2" title="2">
                return int16(s), nil</span>
        case uint8:<span class="cov2" title="2">
                return int16(s), nil</span>
        case float64:<span class="cov2" title="2">
                return int16(s), nil</span>
        case float32:<span class="cov2" title="2">
                return int16(s), nil</span>
        case string:<span class="cov2" title="3">
                v, err := strconv.ParseInt(s, 0, 0)
                if err == nil </span><span class="cov2" title="2">{
                        return int16(v), nil
                }</span>
                <span class="cov1" title="1">return 0, fmt.Errorf("unable to cast %#v of type %T to int16", i, i)</span>
        case bool:<span class="cov3" title="4">
                if s </span><span class="cov2" title="2">{
                        return 1, nil
                }</span>
                <span class="cov2" title="2">return 0, nil</span>
        case nil:<span class="cov2" title="2">
                return 0, nil</span>
        default:<span class="cov1" title="1">
                return 0, fmt.Errorf("unable to cast %#v of type %T to int16", i, i)</span>
        }
}

// ToInt8E casts an interface to an int8 type.
func ToInt8E(i interface{}) (int8, error) <span class="cov6" title="34">{
        i = indirect(i)

        switch s := i.(type) </span>{
        case int:<span class="cov2" title="2">
                return int8(s), nil</span>
        case int64:<span class="cov2" title="2">
                return int8(s), nil</span>
        case int32:<span class="cov2" title="2">
                return int8(s), nil</span>
        case int16:<span class="cov2" title="2">
                return int8(s), nil</span>
        case int8:<span class="cov2" title="2">
                return s, nil</span>
        case uint:<span class="cov2" title="2">
                return int8(s), nil</span>
        case uint64:<span class="cov2" title="2">
                return int8(s), nil</span>
        case uint32:<span class="cov2" title="2">
                return int8(s), nil</span>
        case uint16:<span class="cov2" title="2">
                return int8(s), nil</span>
        case uint8:<span class="cov2" title="2">
                return int8(s), nil</span>
        case float64:<span class="cov2" title="2">
                return int8(s), nil</span>
        case float32:<span class="cov2" title="2">
                return int8(s), nil</span>
        case string:<span class="cov2" title="3">
                v, err := strconv.ParseInt(s, 0, 0)
                if err == nil </span><span class="cov2" title="2">{
                        return int8(v), nil
                }</span>
                <span class="cov1" title="1">return 0, fmt.Errorf("unable to cast %#v of type %T to int8", i, i)</span>
        case bool:<span class="cov3" title="4">
                if s </span><span class="cov2" title="2">{
                        return 1, nil
                }</span>
                <span class="cov2" title="2">return 0, nil</span>
        case nil:<span class="cov2" title="2">
                return 0, nil</span>
        default:<span class="cov1" title="1">
                return 0, fmt.Errorf("unable to cast %#v of type %T to int8", i, i)</span>
        }
}

// ToIntE casts an interface to an int type.
func ToIntE(i interface{}) (int, error) <span class="cov6" title="34">{
        i = indirect(i)

        switch s := i.(type) </span>{
        case int:<span class="cov2" title="2">
                return s, nil</span>
        case int64:<span class="cov2" title="2">
                return int(s), nil</span>
        case int32:<span class="cov2" title="2">
                return int(s), nil</span>
        case int16:<span class="cov2" title="2">
                return int(s), nil</span>
        case int8:<span class="cov2" title="2">
                return int(s), nil</span>
        case uint:<span class="cov2" title="2">
                return int(s), nil</span>
        case uint64:<span class="cov2" title="2">
                return int(s), nil</span>
        case uint32:<span class="cov2" title="2">
                return int(s), nil</span>
        case uint16:<span class="cov2" title="2">
                return int(s), nil</span>
        case uint8:<span class="cov2" title="2">
                return int(s), nil</span>
        case float64:<span class="cov2" title="2">
                return int(s), nil</span>
        case float32:<span class="cov2" title="2">
                return int(s), nil</span>
        case string:<span class="cov2" title="3">
                v, err := strconv.ParseInt(s, 0, 0)
                if err == nil </span><span class="cov2" title="2">{
                        return int(v), nil
                }</span>
                <span class="cov1" title="1">return 0, fmt.Errorf("unable to cast %#v of type %T to int", i, i)</span>
        case bool:<span class="cov3" title="4">
                if s </span><span class="cov2" title="2">{
                        return 1, nil
                }</span>
                <span class="cov2" title="2">return 0, nil</span>
        case nil:<span class="cov2" title="2">
                return 0, nil</span>
        default:<span class="cov1" title="1">
                return 0, fmt.Errorf("unable to cast %#v of type %T to int", i, i)</span>
        }
}

// ToUintE casts an interface to a uint type.
func ToUintE(i interface{}) (uint, error) <span class="cov6" title="42">{
        i = indirect(i)

        switch s := i.(type) </span>{
        case string:<span class="cov3" title="4">
                v, err := strconv.ParseUint(s, 0, 0)
                if err == nil </span><span class="cov2" title="2">{
                        return uint(v), nil
                }</span>
                <span class="cov2" title="2">return 0, fmt.Errorf("unable to cast %#v to uint: %s", i, err)</span>
        case int:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint(s), nil</span>
        case int64:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint(s), nil</span>
        case int32:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint(s), nil</span>
        case int16:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint(s), nil</span>
        case int8:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint(s), nil</span>
        case uint:<span class="cov2" title="2">
                return s, nil</span>
        case uint64:<span class="cov2" title="2">
                return uint(s), nil</span>
        case uint32:<span class="cov2" title="2">
                return uint(s), nil</span>
        case uint16:<span class="cov2" title="2">
                return uint(s), nil</span>
        case uint8:<span class="cov2" title="2">
                return uint(s), nil</span>
        case float64:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint(s), nil</span>
        case float32:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint(s), nil</span>
        case bool:<span class="cov3" title="4">
                if s </span><span class="cov2" title="2">{
                        return 1, nil
                }</span>
                <span class="cov2" title="2">return 0, nil</span>
        case nil:<span class="cov2" title="2">
                return 0, nil</span>
        default:<span class="cov1" title="1">
                return 0, fmt.Errorf("unable to cast %#v of type %T to uint", i, i)</span>
        }
}

// ToUint64E casts an interface to a uint64 type.
func ToUint64E(i interface{}) (uint64, error) <span class="cov6" title="42">{
        i = indirect(i)

        switch s := i.(type) </span>{
        case string:<span class="cov3" title="4">
                v, err := strconv.ParseUint(s, 0, 64)
                if err == nil </span><span class="cov2" title="2">{
                        return v, nil
                }</span>
                <span class="cov2" title="2">return 0, fmt.Errorf("unable to cast %#v to uint64: %s", i, err)</span>
        case int:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint64(s), nil</span>
        case int64:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint64(s), nil</span>
        case int32:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint64(s), nil</span>
        case int16:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint64(s), nil</span>
        case int8:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint64(s), nil</span>
        case uint:<span class="cov2" title="2">
                return uint64(s), nil</span>
        case uint64:<span class="cov2" title="2">
                return s, nil</span>
        case uint32:<span class="cov2" title="2">
                return uint64(s), nil</span>
        case uint16:<span class="cov2" title="2">
                return uint64(s), nil</span>
        case uint8:<span class="cov2" title="2">
                return uint64(s), nil</span>
        case float32:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint64(s), nil</span>
        case float64:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint64(s), nil</span>
        case bool:<span class="cov3" title="4">
                if s </span><span class="cov2" title="2">{
                        return 1, nil
                }</span>
                <span class="cov2" title="2">return 0, nil</span>
        case nil:<span class="cov2" title="2">
                return 0, nil</span>
        default:<span class="cov1" title="1">
                return 0, fmt.Errorf("unable to cast %#v of type %T to uint64", i, i)</span>
        }
}

// ToUint32E casts an interface to a uint32 type.
func ToUint32E(i interface{}) (uint32, error) <span class="cov6" title="42">{
        i = indirect(i)

        switch s := i.(type) </span>{
        case string:<span class="cov3" title="4">
                v, err := strconv.ParseUint(s, 0, 32)
                if err == nil </span><span class="cov2" title="2">{
                        return uint32(v), nil
                }</span>
                <span class="cov2" title="2">return 0, fmt.Errorf("unable to cast %#v to uint32: %s", i, err)</span>
        case int:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint32(s), nil</span>
        case int64:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint32(s), nil</span>
        case int32:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint32(s), nil</span>
        case int16:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint32(s), nil</span>
        case int8:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint32(s), nil</span>
        case uint:<span class="cov2" title="2">
                return uint32(s), nil</span>
        case uint64:<span class="cov2" title="2">
                return uint32(s), nil</span>
        case uint32:<span class="cov2" title="2">
                return s, nil</span>
        case uint16:<span class="cov2" title="2">
                return uint32(s), nil</span>
        case uint8:<span class="cov2" title="2">
                return uint32(s), nil</span>
        case float64:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint32(s), nil</span>
        case float32:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint32(s), nil</span>
        case bool:<span class="cov3" title="4">
                if s </span><span class="cov2" title="2">{
                        return 1, nil
                }</span>
                <span class="cov2" title="2">return 0, nil</span>
        case nil:<span class="cov2" title="2">
                return 0, nil</span>
        default:<span class="cov1" title="1">
                return 0, fmt.Errorf("unable to cast %#v of type %T to uint32", i, i)</span>
        }
}

// ToUint16E casts an interface to a uint16 type.
func ToUint16E(i interface{}) (uint16, error) <span class="cov6" title="42">{
        i = indirect(i)

        switch s := i.(type) </span>{
        case string:<span class="cov3" title="4">
                v, err := strconv.ParseUint(s, 0, 16)
                if err == nil </span><span class="cov2" title="2">{
                        return uint16(v), nil
                }</span>
                <span class="cov2" title="2">return 0, fmt.Errorf("unable to cast %#v to uint16: %s", i, err)</span>
        case int:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint16(s), nil</span>
        case int64:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint16(s), nil</span>
        case int32:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint16(s), nil</span>
        case int16:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint16(s), nil</span>
        case int8:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint16(s), nil</span>
        case uint:<span class="cov2" title="2">
                return uint16(s), nil</span>
        case uint64:<span class="cov2" title="2">
                return uint16(s), nil</span>
        case uint32:<span class="cov2" title="2">
                return uint16(s), nil</span>
        case uint16:<span class="cov2" title="2">
                return s, nil</span>
        case uint8:<span class="cov2" title="2">
                return uint16(s), nil</span>
        case float64:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint16(s), nil</span>
        case float32:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint16(s), nil</span>
        case bool:<span class="cov3" title="4">
                if s </span><span class="cov2" title="2">{
                        return 1, nil
                }</span>
                <span class="cov2" title="2">return 0, nil</span>
        case nil:<span class="cov2" title="2">
                return 0, nil</span>
        default:<span class="cov1" title="1">
                return 0, fmt.Errorf("unable to cast %#v of type %T to uint16", i, i)</span>
        }
}

// ToUint8E casts an interface to a uint type.
func ToUint8E(i interface{}) (uint8, error) <span class="cov6" title="42">{
        i = indirect(i)

        switch s := i.(type) </span>{
        case string:<span class="cov3" title="4">
                v, err := strconv.ParseUint(s, 0, 8)
                if err == nil </span><span class="cov2" title="2">{
                        return uint8(v), nil
                }</span>
                <span class="cov2" title="2">return 0, fmt.Errorf("unable to cast %#v to uint8: %s", i, err)</span>
        case int:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint8(s), nil</span>
        case int64:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint8(s), nil</span>
        case int32:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint8(s), nil</span>
        case int16:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint8(s), nil</span>
        case int8:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint8(s), nil</span>
        case uint:<span class="cov2" title="2">
                return uint8(s), nil</span>
        case uint64:<span class="cov2" title="2">
                return uint8(s), nil</span>
        case uint32:<span class="cov2" title="2">
                return uint8(s), nil</span>
        case uint16:<span class="cov2" title="2">
                return uint8(s), nil</span>
        case uint8:<span class="cov2" title="2">
                return s, nil</span>
        case float64:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint8(s), nil</span>
        case float32:<span class="cov2" title="3">
                if s &lt; 0 </span><span class="cov1" title="1">{
                        return 0, errNegativeNotAllowed
                }</span>
                <span class="cov2" title="2">return uint8(s), nil</span>
        case bool:<span class="cov3" title="4">
                if s </span><span class="cov2" title="2">{
                        return 1, nil
                }</span>
                <span class="cov2" title="2">return 0, nil</span>
        case nil:<span class="cov2" title="2">
                return 0, nil</span>
        default:<span class="cov1" title="1">
                return 0, fmt.Errorf("unable to cast %#v of type %T to uint8", i, i)</span>
        }
}

// From html/template/content.go
// Copyright 2011 The Go Authors. All rights reserved.
// indirect returns the value, after dereferencing as many times
// as necessary to reach the base type (or nil).
func indirect(a interface{}) interface{} <span class="cov10" title="444">{
        if a == nil </span><span class="cov5" title="20">{
                return nil
        }</span>
        <span class="cov9" title="424">if t := reflect.TypeOf(a); t.Kind() != reflect.Ptr </span><span class="cov9" title="424">{
                // Avoid creating a reflect.Value if it's not a pointer.
                return a
        }</span>
        <span class="cov0" title="0">v := reflect.ValueOf(a)
        for v.Kind() == reflect.Ptr &amp;&amp; !v.IsNil() </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>
        <span class="cov0" title="0">return v.Interface()</span>
}

// From html/template/content.go
// Copyright 2011 The Go Authors. All rights reserved.
// indirectToStringerOrError returns the value, after dereferencing as many times
// as necessary to reach the base type (or nil) or an implementation of fmt.Stringer
// or error,
func indirectToStringerOrError(a interface{}) interface{} <span class="cov6" title="48">{
        if a == nil </span><span class="cov2" title="2">{
                return nil
        }</span>

        <span class="cov6" title="46">var errorType = reflect.TypeOf((*error)(nil)).Elem()
        var fmtStringerType = reflect.TypeOf((*fmt.Stringer)(nil)).Elem()

        v := reflect.ValueOf(a)
        for !v.Type().Implements(fmtStringerType) &amp;&amp; !v.Type().Implements(errorType) &amp;&amp; v.Kind() == reflect.Ptr &amp;&amp; !v.IsNil() </span><span class="cov1" title="1">{
                v = v.Elem()
        }</span>
        <span class="cov6" title="46">return v.Interface()</span>
}

// ToStringE casts an interface to a string type.
func ToStringE(i interface{}) (string, error) <span class="cov6" title="48">{
        i = indirectToStringerOrError(i)

        switch s := i.(type) </span>{
        case string:<span class="cov2" title="2">
                return s, nil</span>
        case bool:<span class="cov3" title="4">
                return strconv.FormatBool(s), nil</span>
        case float64:<span class="cov2" title="2">
                return strconv.FormatFloat(s, 'f', -1, 64), nil</span>
        case float32:<span class="cov2" title="2">
                return strconv.FormatFloat(float64(s), 'f', -1, 32), nil</span>
        case int:<span class="cov2" title="2">
                return strconv.Itoa(s), nil</span>
        case int64:<span class="cov2" title="2">
                return strconv.FormatInt(s, 10), nil</span>
        case int32:<span class="cov2" title="2">
                return strconv.Itoa(int(s)), nil</span>
        case int16:<span class="cov2" title="2">
                return strconv.FormatInt(int64(s), 10), nil</span>
        case int8:<span class="cov2" title="2">
                return strconv.FormatInt(int64(s), 10), nil</span>
        case uint:<span class="cov2" title="2">
                return strconv.FormatUint(uint64(s), 10), nil</span>
        case uint64:<span class="cov2" title="2">
                return strconv.FormatUint(uint64(s), 10), nil</span>
        case uint32:<span class="cov2" title="2">
                return strconv.FormatUint(uint64(s), 10), nil</span>
        case uint16:<span class="cov2" title="2">
                return strconv.FormatUint(uint64(s), 10), nil</span>
        case uint8:<span class="cov2" title="2">
                return strconv.FormatUint(uint64(s), 10), nil</span>
        case []byte:<span class="cov2" title="2">
                return string(s), nil</span>
        case template.HTML:<span class="cov2" title="2">
                return string(s), nil</span>
        case template.URL:<span class="cov2" title="2">
                return string(s), nil</span>
        case template.JS:<span class="cov2" title="2">
                return string(s), nil</span>
        case template.CSS:<span class="cov2" title="2">
                return string(s), nil</span>
        case template.HTMLAttr:<span class="cov2" title="2">
                return string(s), nil</span>
        case nil:<span class="cov2" title="2">
                return "", nil</span>
        case fmt.Stringer:<span class="cov1" title="1">
                return s.String(), nil</span>
        case error:<span class="cov1" title="1">
                return s.Error(), nil</span>
        default:<span class="cov2" title="2">
                return "", fmt.Errorf("unable to cast %#v of type %T to string", i, i)</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package parser

type Any interface{}

type Generator interface {
        Get() Any
        Merge(Generator) Generator
}

type valueGenerator struct {
        value Any
}

func (vg *valueGenerator) Get() Any <span class="cov5" title="8">{
        return vg.value
}</span>

func (vg *valueGenerator) Merge(g Generator) Generator <span class="cov6" title="15">{
        // Values cannot be merged. Return the new one
        return g
}</span>

func mkValueGenerator(v Any) *valueGenerator <span class="cov10" title="82">{
        return &amp;valueGenerator{value: v}
}</span>

type ObjectGenerator struct {
        fields map[string]Generator
}

func mkObjectGenerator() *ObjectGenerator <span class="cov8" title="47">{
        return &amp;ObjectGenerator{
                fields: map[string]Generator{},
        }
}</span>

func (obj *ObjectGenerator) add(field string, value Generator) *ObjectGenerator <span class="cov9" title="62">{
        if gen, ok := obj.fields[field]; ok </span><span class="cov1" title="1">{
                value = gen.Merge(value)
        }</span>
        <span class="cov9" title="62">obj.fields[field] = value
        return obj</span>
}

func (obj *ObjectGenerator) Get() Any <span class="cov0" title="0">{
        res := map[string]Any{}
        for field, vg := range obj.fields </span><span class="cov0" title="0">{
                res[field] = vg.Get()
        }</span>
        <span class="cov0" title="0">return res</span>
}

func (obj *ObjectGenerator) Merge(g Generator) Generator <span class="cov1" title="1">{
        switch gt := g.(type) </span>{
        case *ObjectGenerator:<span class="cov1" title="1">
                // Objects can be merged together
                res := mkObjectGenerator()
                for f, v := range obj.fields </span><span class="cov1" title="1">{
                        res.add(f, v)
                }</span>
                <span class="cov1" title="1">for f, v := range gt.fields </span><span class="cov1" title="1">{
                        res.add(f, v)
                }</span>
                <span class="cov1" title="1">return res</span>
        default:<span class="cov0" title="0">
                // other types, less so, return the new one
                return g</span>
        }
}

type arrayGenerator []Generator

func (arr *arrayGenerator) Merge(g Generator) Generator <span class="cov3" title="3">{
        // arrays can' t be merged with other generators
        return g
}</span>

func (arr *arrayGenerator) Get() Any <span class="cov1" title="1">{
        res := make([]Any, len(*arr))
        for idx, el := range *arr </span><span class="cov3" title="3">{
                res[idx] = el.Get()
        }</span>
        <span class="cov1" title="1">return res</span>
}

func (arr *arrayGenerator) add(g Generator) Generator <span class="cov4" title="5">{
        *arr = append(*arr, g)
        return arr
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package parser

import (
        "fmt"
        "strings"
        "unicode"
        "unicode/utf8"
)

const eof = -1

type lexer struct {
        input     string    // the string being scanned
        pos       int       // current position in the input
        start     int       // start position of this item
        width     int       // width of last rune read from input
        line      int       // 1+number of newlines seen
        startLine int       // start line of this item
        lastSeen  tokenType // the last seen token type
}

// newLexer creates a new scanner for the input string.
func newLexer(input string) *lexer <span class="cov5" title="29">{
        l := &amp;lexer{
                input:     input,
                line:      1,
                startLine: 1,
        }

        return l
}</span>

func (l *lexer) nextToken() token <span class="cov7" title="234">{
        for </span><span class="cov7" title="234">{
                l.skipSpaces()

                switch r := l.pop(); </span>{
                case r == eof:<span class="cov5" title="48">
                        return l.emit(ttEof)</span>
                case r == '{':<span class="cov3" title="8">
                        return l.emit(ttLeftBrace)</span>
                case r == '}':<span class="cov3" title="8">
                        return l.emit(ttRightBrace)</span>
                case r == '[':<span class="cov1" title="1">
                        return l.emit(ttLeftBracket)</span>
                case r == ']':<span class="cov1" title="1">
                        return l.emit(ttRightBracket)</span>
                case r == '=':<span class="cov5" title="49">
                        return l.emit(ttAssign)</span>
                case r == '"':<span class="cov3" title="10">
                        return l.lexQuotedString()</span>
                case r == '(':<span class="cov3" title="7">
                        return l.lexExpression()</span>
                case r == '.':<span class="cov3" title="10">
                        x := l.peek()
                        if x &lt; '0' || '9' &lt; x </span><span class="cov3" title="10">{
                                return l.emit(ttDot)
                        }</span>
                        <span class="cov0" title="0">fallthrough</span> // '.' can start a number.
                case r == '+' || r == '-' || ('0' &lt;= r &amp;&amp; r &lt;= '9'):<span class="cov4" title="14">
                        l.push()
                        return l.lexNumber()</span>
                case isAlphaNumeric(r):<span class="cov6" title="78">
                        l.push()
                        return l.lexIdentifier()</span>
                default:<span class="cov0" title="0">
                        l.push()
                        return l.errorf("unrecognized character: %#U", r)</span>
                }
        }
}

// lexIdentifier scans an alphanumeric.
func (l *lexer) lexIdentifier() token <span class="cov6" title="78">{
        for </span><span class="cov8" title="362">{
                switch r := l.pop(); </span>{
                case isAlphaNumeric(r):<span class="cov8" title="284"></span>
                        // absorb.
                default:<span class="cov6" title="78">
                        l.push()

                        if l.lastSeen != ttAssign &amp;&amp; !l.atTerminator() </span><span class="cov0" title="0">{
                                return l.errorf("bad character %#U", r)
                        }</span>

                        <span class="cov6" title="78">word := l.input[l.start:l.pos]
                        if key[word] &gt; ttKeyword </span><span class="cov3" title="9">{
                                return l.emit(key[word])
                        }</span>

                        <span class="cov6" title="69">if l.lastSeen == ttAssign </span><span class="cov4" title="12">{
                                return l.emit(ttString)
                        }</span>

                        <span class="cov6" title="57">return l.emit(ttIdentifier)</span>
                }
        }
}

// lexQuotedString scans a quoted string.
func (l *lexer) lexQuotedString() token <span class="cov3" title="10">{
Loop:
        for </span><span class="cov6" title="85">{
                switch l.pop() </span>{
                case '\\':<span class="cov0" title="0">
                        if r := l.pop(); r != eof &amp;&amp; r != '\n' </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">fallthrough</span>
                case eof, '\n':<span class="cov0" title="0">
                        return l.errorf("unterminated quoted string")</span>
                case '"':<span class="cov3" title="10">
                        break Loop</span>
                }
        }

        <span class="cov3" title="10">val := l.input[l.start+1 : l.pos-1]
        return l.emitV(ttString, val)</span>
}

// lexExpression scans an expression string.
func (l *lexer) lexExpression() token <span class="cov3" title="7">{
Loop:
        for </span><span class="cov6" title="119">{
                switch l.pop() </span>{
                case '\\':<span class="cov0" title="0">
                        if r := l.pop(); r != eof &amp;&amp; r != '\n' </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">fallthrough</span>
                case eof, '\n':<span class="cov0" title="0">
                        return l.errorf("unterminated round bracket string")</span>
                case ')':<span class="cov3" title="7">
                        break Loop</span>
                }
        }

        <span class="cov3" title="7">val := l.input[l.start+1 : l.pos-1]
        return l.emitV(ttExpression, val)</span>
}

// atTerminator reports whether the input is at valid termination character to
// appear after an identifier.
func (l *lexer) atTerminator() bool <span class="cov6" title="60">{
        r := l.peek()
        if isSpace(r) </span><span class="cov3" title="7">{
                return true
        }</span>

        <span class="cov5" title="53">switch r </span>{
        case eof, '=', '.', '[', ']', '{', '}':<span class="cov5" title="53">
                return true</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (l *lexer) lexNumber() token <span class="cov4" title="14">{
        if !l.scanNumber() </span><span class="cov0" title="0">{
                return l.errorf("bad number syntax: %q", l.input[l.start:l.pos])
        }</span>

        <span class="cov4" title="14">if sign := l.peek(); sign == '+' || sign == '-' </span><span class="cov0" title="0">{
                // Complex: 1+2i. No spaces, must end in 'i'.
                if !l.scanNumber() || l.input[l.pos-1] != 'i' </span><span class="cov0" title="0">{
                        return l.errorf("bad number syntax: %q", l.input[l.start:l.pos])
                }</span>

                <span class="cov0" title="0">return l.emit(ttComplex)</span>
        }

        <span class="cov4" title="14">return l.emit(ttNumber)</span>
}

func (l *lexer) scanNumber() bool <span class="cov4" title="14">{
        // Optional leading sign.
        l.accept("+-")

        // Is it hex?
        digits := "0123456789_"
        if l.accept("0") </span><span class="cov1" title="1">{
                // Note: Leading 0 does not mean octal in floats.
                if l.accept("xX") </span><span class="cov1" title="1">{
                        digits = "0123456789abcdefABCDEF_"
                }</span> else<span class="cov0" title="0"> if l.accept("oO") </span><span class="cov0" title="0">{
                        digits = "01234567_"
                }</span> else<span class="cov0" title="0"> if l.accept("bB") </span><span class="cov0" title="0">{
                        digits = "01_"
                }</span>
        }

        <span class="cov4" title="14">l.acceptRun(digits)
        if l.accept(".") </span><span class="cov3" title="6">{
                l.acceptRun(digits)
        }</span>

        <span class="cov4" title="14">if len(digits) == 10+1 &amp;&amp; l.accept("eE") </span><span class="cov1" title="2">{
                l.accept("+-")
                l.acceptRun("0123456789_")
        }</span>

        <span class="cov4" title="14">if len(digits) == 16+6+1 &amp;&amp; l.accept("pP") </span><span class="cov0" title="0">{
                l.accept("+-")
                l.acceptRun("0123456789_")
        }</span>

        // Is it imaginary?
        <span class="cov4" title="14">l.accept("i")

        // Next thing mustn't be alphanumeric.
        if isAlphaNumeric(l.peek()) </span><span class="cov0" title="0">{
                l.pop()
                return false
        }</span>

        <span class="cov4" title="14">return true</span>
}

// skipSpaces eats all spaces.
func (l *lexer) skipSpaces() <span class="cov7" title="234">{
        for isSpace(l.peek()) </span><span class="cov5" title="51">{
                l.pop()
        }</span>
        <span class="cov7" title="234">l.drop()</span>
}

// pop returns the next rune in the input.
func (l *lexer) pop() rune <span class="cov10" title="1361">{
        if l.pos &gt;= len(l.input) </span><span class="cov6" title="121">{
                l.width = 0
                return eof
        }</span>

        <span class="cov9" title="1240">r, w := utf8.DecodeRuneInString(l.input[l.pos:])
        l.width = w
        l.pos += l.width

        if r == '\n' </span><span class="cov1" title="2">{
                l.line++
        }</span>

        <span class="cov9" title="1240">return r</span>
}

// peek returns but does not consume the next rune in the input.
func (l *lexer) peek() rune <span class="cov8" title="383">{
        r := l.pop()
        l.push()
        return r
}</span>

// push steps back one rune. Can only be called once per call of next.
func (l *lexer) push() <span class="cov9" title="635">{
        l.pos -= l.width
        // Correct newline count.
        if l.width == 1 &amp;&amp; l.input[l.pos] == '\n' </span><span class="cov1" title="1">{
                l.line--
        }</span>
}

func (l *lexer) drop() <span class="cov7" title="234">{
        l.start = l.pos
}</span>

// accept consumes the next rune if it's from the valid set.
func (l *lexer) accept(valid string) bool <span class="cov6" title="73">{
        if strings.ContainsRune(valid, l.pop()) </span><span class="cov4" title="13">{
                return true
        }</span>
        <span class="cov6" title="60">l.push()

        return false</span>
}

// acceptRun consumes a run of runes from the valid set.
func (l *lexer) acceptRun(valid string) <span class="cov4" title="22">{
        for strings.ContainsRune(valid, l.pop()) </span>{<span class="cov5" title="32">

        }</span>
        <span class="cov4" title="22">l.push()</span>
}

func (l *lexer) emit(typ tokenType) token <span class="cov7" title="217">{
        val := l.input[l.start:l.pos]
        return l.emitV(typ, val)
}</span>

func (l *lexer) emitV(typ tokenType, v string) token <span class="cov7" title="234">{
        res := token{
                typ:  typ,
                val:  v,
                pos:  l.start,
                line: l.line,
        }
        l.start = l.pos
        l.lastSeen = typ
        return res
}</span>

// errorf returns an error token and terminates the scan by passing
// back a nil pointer that will be the next state, terminating l.nextItem.
func (l *lexer) errorf(format string, args ...interface{}) token <span class="cov0" title="0">{
        return l.emitV(ttError, fmt.Sprintf(format, args...))
}</span>

// isSpace reports whether r is a space character.
func isSpace(r rune) bool <span class="cov8" title="345">{
        return r == ' ' || r == '\t' || r == '\r' || r == '\n'
}</span>

// isAlphaNumeric reports whether r is an alphabetic, digit, underscore or dash.
func isAlphaNumeric(r rune) bool <span class="cov8" title="454">{
        return r == '_' ||
                r == '-' ||
                unicode.IsLetter(r) ||
                unicode.IsDigit(r)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package parser

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/lucasepe/yo/internal/template"
)

// parseError is returned if the input cannot be successfuly parsed
type parseError struct {
        // The original query
        input string
        // The position where the parsing fails
        pos int
        // The error message
        message string
}

func (e parseError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("parse error: %s\n%s\n%s^", e.message, e.input, strings.Repeat(" ", e.pos))
}</span>

type parser struct {
        lexer   *lexer
        matched token
        next    token
}

func newParser(lex *lexer) *parser <span class="cov5" title="19">{
        return (&amp;parser{
                lexer: lex,
                next:  lex.nextToken(),
        })
}</span>

func (p *parser) parse() (gen []Generator, err error) <span class="cov5" title="19">{
        defer func() </span><span class="cov5" title="19">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        gen = nil
                        err = parseError{
                                input:   p.lexer.input,
                                pos:     p.matched.pos,
                                message: fmt.Sprintf("%v", r),
                        }
                }</span>
        }()
        <span class="cov5" title="19">gen = p.run()
        if !p.found(ttEof) </span><span class="cov0" title="0">{
                p.advance()
                panic("unexpected input")</span>
        }
        <span class="cov5" title="19">return</span>
}

func (p *parser) run() []Generator <span class="cov5" title="19">{
        p.peek()
        if p.peek(ttLeftBrace) || p.peek(ttLeftBracket) </span><span class="cov0" title="0">{
                res := []Generator{}
                for </span><span class="cov0" title="0">{
                        switch </span>{
                        case p.found(ttLeftBrace):<span class="cov0" title="0">
                                res = append(res, p.object())</span>
                        case p.found(ttLeftBracket):<span class="cov0" title="0">
                                res = append(res, p.array())</span>
                        default:<span class="cov0" title="0">
                                return res</span>
                        }
                }
        }

        <span class="cov5" title="19">objGen := mkObjectGenerator()
        for p.found(ttIdentifier) </span><span class="cov5" title="28">{
                if p.peek(ttAssign) || p.peek(ttDot) </span><span class="cov5" title="28">{
                        field := p.matched.val
                        value := p.field(field)
                        objGen.add(field, value)
                }</span>
        }

        <span class="cov5" title="19">return []Generator{objGen}</span>
}

func (p *parser) object() Generator <span class="cov3" title="5">{
        res := mkObjectGenerator()
        for p.found(ttIdentifier) </span><span class="cov4" title="12">{
                if p.peek(ttAssign) || p.peek(ttDot) </span><span class="cov4" title="12">{
                        field := p.matched.val
                        value := p.field(field)
                        res.add(field, value)
                }</span>
        }

        <span class="cov3" title="5">if err := p.expect(ttRightBrace); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov3" title="5">return res</span>
}

func (p *parser) array() Generator <span class="cov1" title="1">{
        res := &amp;arrayGenerator{}

        for </span><span class="cov2" title="3">{
                switch </span>{
                case p.found(ttExpression):<span class="cov1" title="1">
                        src, err := template.ExecuteInline(nil, fmt.Sprintf("{{%s}}", p.matched.val))
                        if err != nil </span><span class="cov0" title="0">{
                                panic(err)</span>
                        }
                        <span class="cov1" title="1">v := mkValueGenerator(string(src))
                        res.add(v)</span>

                case p.found(ttString):<span class="cov0" title="0">
                        fmt.Println(" - found string", p.matched.val)
                        v := mkValueGenerator(p.matched.val)
                        res.add(v)</span>

                case p.found(ttNil):<span class="cov0" title="0">
                        return mkValueGenerator(nil)</span>

                case p.found(ttNumber):<span class="cov0" title="0">
                        src, err := parseNumber(p.matched.val)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(err)</span>
                        }
                        <span class="cov0" title="0">v := mkValueGenerator(src)
                        res.add(v)</span>

                case p.found(ttComplex):<span class="cov0" title="0">
                        src, err := parseComplex(p.matched.val)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(err)</span>
                        }
                        <span class="cov0" title="0">v := mkValueGenerator(src)
                        res.add(v)</span>

                case p.found(ttBool):<span class="cov0" title="0">
                        src, err := parseBool(p.matched.val)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(err)</span>
                        }
                        <span class="cov0" title="0">v := mkValueGenerator(src)
                        res.add(v)</span>

                case p.found(ttIdentifier):<span class="cov1" title="1">
                        if p.peek(ttAssign) || p.peek(ttDot) </span><span class="cov0" title="0">{
                                field := p.matched.val
                                value := p.field(field)
                                // Add 1-field obj to array
                                obj := mkObjectGenerator()
                                obj.add(field, value)
                                res.add(obj)
                        }</span> else<span class="cov1" title="1"> {
                                res.add(mkValueGenerator(p.matched.val))
                        }</span>
                case p.found(ttLeftBrace):<span class="cov0" title="0">
                        res.add(p.object())</span>
                        //Add obj as array elem
                case p.found(ttLeftBracket):<span class="cov0" title="0">
                        res.add(p.array())</span>
                        // Add array as arr elem
                case p.found(ttRightBracket):<span class="cov1" title="1">
                        // return, the array is complete
                        return res</span>

                case p.found(ttEof):<span class="cov0" title="0">
                        panic("unclosed array")</span>
                default:<span class="cov0" title="0">
                        p.advance()
                        panic("unexpected input")</span>
                }
        }
}

func (p *parser) field(field string) Generator <span class="cov6" title="48">{
        switch </span>{
        case p.found(ttAssign):<span class="cov6" title="40">
                return p.value()</span>
        case p.found(ttDot):<span class="cov4" title="8">
                //nolint:errcheck
                p.expect(ttIdentifier)

                field := p.matched.val
                value := p.field(field)
                return mkObjectGenerator().add(field, value)</span>
        case p.found(ttEof):<span class="cov0" title="0">
                panic("unexpected end of input")</span>
        default:<span class="cov0" title="0">
                p.advance()
                panic("unexpected input")</span>
        }
}

func (p *parser) value() Generator <span class="cov6" title="40">{
        switch </span>{
        case p.found(ttExpression):<span class="cov3" title="5">
                res, err := template.ExecuteInline(nil, fmt.Sprintf("{{%s}}", p.matched.val))
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov3" title="5">return mkValueGenerator(string(res))</span>

        case p.found(ttString):<span class="cov5" title="18">
                return mkValueGenerator(p.matched.val)</span>

        case p.found(ttNil):<span class="cov1" title="1">
                return mkValueGenerator(nil)</span>

        case p.found(ttNumber):<span class="cov3" title="6">
                res, err := parseNumber(p.matched.val)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov3" title="6">return mkValueGenerator(res)</span>

        case p.found(ttComplex):<span class="cov0" title="0">
                res, err := parseComplex(p.matched.val)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov0" title="0">return mkValueGenerator(res)</span>

        case p.found(ttBool):<span class="cov3" title="4">
                res, err := parseBool(p.matched.val)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov3" title="4">return mkValueGenerator(res)</span>

        case p.found(ttLeftBrace):<span class="cov3" title="5">
                return p.object()</span>

        case p.found(ttLeftBracket):<span class="cov1" title="1">
                return p.array()</span>

        case p.found(ttEof):<span class="cov0" title="0">
                panic("unexpected end of input")</span>

        case p.found(ttError):<span class="cov0" title="0">
                panic(p.matched.val)</span>

        default:<span class="cov0" title="0">
                p.advance()
                panic("unexpected input")</span>
        }
}

func (p *parser) peek(tts ...tokenType) bool <span class="cov10" title="410">{
        for _, v := range tts </span><span class="cov9" title="391">{
                if p.next.typ == v </span><span class="cov8" title="202">{
                        return true
                }</span>
        }

        <span class="cov8" title="208">return false</span>
}

func (p *parser) found(tts ...tokenType) bool <span class="cov9" title="305">{
        if p.peek(tts...) </span><span class="cov8" title="162">{
                p.advance()
                return true
        }</span>
        <span class="cov8" title="143">return false</span>
}

func (p *parser) expect(tts ...tokenType) error <span class="cov4" title="13">{
        if !p.found(tts...) </span><span class="cov1" title="1">{
                p.advance()
                return fmt.Errorf("was expecting %v", tts)
        }</span>
        <span class="cov4" title="12">return nil</span>
}

func (p *parser) advance() <span class="cov8" title="163">{
        p.matched = p.next
        p.next = p.lexer.nextToken()
}</span>

func parseComplex(value string) (Any, error) <span class="cov0" title="0">{
        res, err := strconv.ParseComplex(value, 128)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid literal %q: is not a complex number", value)
        }</span>
        <span class="cov0" title="0">return res, nil</span>
}

func parseBool(value string) (Any, error) <span class="cov3" title="4">{
        switch </span>{
        case value == "true":<span class="cov2" title="3">
                return true, nil</span>
        case value == "false":<span class="cov1" title="1">
                return false, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("invalid literal %q: is not a boolean", value)</span>
        }
}

func parseNumber(value string) (Any, error) <span class="cov3" title="6">{
        var v Any
        v, err := strconv.ParseInt(value, 10, 64)
        if err != nil </span><span class="cov2" title="2">{
                v, err = strconv.ParseFloat(value, 64)
        }</span>
        <span class="cov3" title="6">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid literal %q: is not a integer or a float number", value)
        }</span>
        <span class="cov3" title="6">return v, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package parser

import (
        "bufio"
        "io"
        "strings"
)

const (
        scannerBuffer = 128 * 1024
)

// ParseString accepts an input string and
// Returns either a slice of Generators on success or else an error.
func ParseString(input string) ([]Generator, error) <span class="cov10" title="19">{
        lexer := newLexer(input)
        return newParser(lexer).parse()
        /*
                return (&amp;parser{
                        lexer: lexer,
                        next:  lexer.nextToken(),
                }).parse()
        */
}</span>

// ParseTextLines parse a slice of lines.
// Returns either a slice of Generators on success or else an error.
func ParseTextLines(lines []string) ([]Generator, error) <span class="cov0" title="0">{
        spec := strings.Join(lines, " ")
        return ParseString(spec)
}</span>

// ParseTextLines parse a reader.
// Returns either a slice of Generators on success or else an error.
func ParseReader(reader io.Reader) ([]Generator, error) <span class="cov0" title="0">{
        buffer := make([]byte, scannerBuffer)

        scanner := bufio.NewScanner(reader)
        scanner.Buffer(buffer, scannerBuffer)

        res := []string{}

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                res = append(res, line)
        }</span>

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return ParseTextLines(res)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package parser

import "fmt"

// tokenType identifies the type of lex tokens.
type tokenType int

const (
        ttEof tokenType = -1

        ttError   tokenType = iota // error occurred; value is text of error
        ttComplex                  // complex constant (1+2i); imaginary is just a number
        ttAssign                   // equals ('=') introducing an assignment

        ttIdentifier   // alphanumeric identifier
        ttLeftBrace    // '{' object begin
        ttRightBrace   // '}' object end
        ttLeftBracket  // '[' array begin
        ttRightBracket // ']' array end
        //ttLeftRoundBracket  // '(' expression begin
        //ttRightRoundBracket // ')' expression end
        ttNumber     // simple number, including imaginary
        ttString     // string (without quotes)
        ttExpression // template expression (without round brackets)

        // Keywords appear after all the rest.
        ttKeyword // used only to delimit the keywords
        ttBool    // boolean constant (true or false)
        ttDot     // the cursor, spelled '.'
        ttNil     // the untyped nil constant, easiest to treat as a keyword
)

// item represents a token or text string returned from the scanner.
type token struct {
        typ  tokenType // The type of this item.
        pos  int       // The starting position, in bytes, of this item in the input string.
        val  string    // The value of this item.
        line int       // The line number at the start of this item.
}

func (t token) String() string <span class="cov0" title="0">{
        switch </span>{
        case t.typ == ttEof:<span class="cov0" title="0">
                return "EOF"</span>
        case t.typ == ttError:<span class="cov0" title="0">
                return t.val</span>
        case t.typ &gt; ttKeyword:<span class="cov0" title="0">
                return fmt.Sprintf("&lt;%s&gt;", t.val)</span>
        case len(t.val) &gt; 10:<span class="cov0" title="0">
                return fmt.Sprintf("%.10q...", t.val)</span>
        }
        <span class="cov0" title="0">return fmt.Sprintf("%q", t.val)</span>
}

var key = map[string]tokenType{
        ".":     ttDot,
        "true":  ttBool,
        "false": ttBool,
        "null":  ttNil,
        "nil":   ttNil,
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package template

import (
        "crypto/sha1"
        "crypto/sha256"
        "encoding/hex"

        "github.com/google/uuid"
)

func sha256sum(input string) string <span class="cov1" title="1">{
        hash := sha256.Sum256([]byte(input))
        return hex.EncodeToString(hash[:])
}</span>

func sha1sum(input string) string <span class="cov1" title="1">{
        hash := sha1.Sum([]byte(input))
        return hex.EncodeToString(hash[:])
}</span>

// uuidv4 provides a safe and secure UUID v4 implementation
func uuidv4() string <span class="cov10" title="2">{
        return uuid.New().String()
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package template

import (
        "fmt"
        "strconv"
        "time"
)

// Given a format and a date, format the date string.
//
// Date can be a `time.Time` or an `int, int32, int64`.
// In the later case, it is treated as seconds since UNIX
// epoch.
func date(fmt string, date interface{}) string <span class="cov1" title="1">{
        return dateInZone(fmt, date, "Local")
}</span>

func dateInZone(fmt string, date interface{}, zone string) string <span class="cov10" title="8">{
        var t time.Time
        switch date := date.(type) </span>{
        default:<span class="cov1" title="1">
                t = time.Now()</span>
        case time.Time:<span class="cov5" title="3">
                t = date</span>
        case *time.Time:<span class="cov1" title="1">
                t = *date</span>
        case int64:<span class="cov1" title="1">
                t = time.Unix(date, 0)</span>
        case int:<span class="cov1" title="1">
                t = time.Unix(int64(date), 0)</span>
        case int32:<span class="cov1" title="1">
                t = time.Unix(int64(date), 0)</span>
        }

        <span class="cov10" title="8">loc, err := time.LoadLocation(zone)
        if err != nil </span><span class="cov1" title="1">{
                loc, _ = time.LoadLocation("UTC")
        }</span>

        <span class="cov10" title="8">return t.In(loc).Format(fmt)</span>
}

func dateModify(fmt string, date time.Time) (time.Time, error) <span class="cov0" title="0">{
        d, err := time.ParseDuration(fmt)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>
        <span class="cov0" title="0">return date.Add(d), nil</span>
}

func dateAgo(date interface{}) string <span class="cov5" title="3">{
        var t time.Time

        switch date := date.(type) </span>{
        default:<span class="cov0" title="0">
                t = time.Now()</span>
        case time.Time:<span class="cov5" title="3">
                t = date</span>
        case int64:<span class="cov0" title="0">
                t = time.Unix(date, 0)</span>
        case int:<span class="cov0" title="0">
                t = time.Unix(int64(date), 0)</span>
        }
        // Drop resolution to seconds
        <span class="cov5" title="3">duration := time.Since(t).Round(time.Second)
        return duration.String()</span>
}

func duration(sec interface{}) string <span class="cov5" title="3">{
        var n int64
        switch value := sec.(type) </span>{
        default:<span class="cov0" title="0">
                fmt.Printf("%T\n", value)
                n = 0</span>
        case string:<span class="cov5" title="3">
                n, _ = strconv.ParseInt(value, 10, 64)</span>
        case int64:<span class="cov0" title="0">
                n = value</span>
        case int32:<span class="cov0" title="0"></span>
        case int:<span class="cov0" title="0">
                n = int64(value)</span>
        }
        <span class="cov5" title="3">return (time.Duration(n) * time.Second).String()</span>
}

func toDate(fmt, str string) (time.Time, error) <span class="cov1" title="1">{
        return time.ParseInLocation(fmt, str, time.Local)
}</span>

func unixEpoch(date time.Time) string <span class="cov1" title="1">{
        return strconv.FormatInt(date.Unix(), 10)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package template

import (
        "reflect"
)

// dfault checks whether `given` is set, and returns default if not set.
//
// This returns `d` if `given` appears not to be set, and `given` otherwise.
//
// For numeric types 0 is unset.
// For strings, maps, arrays, and slices, len() = 0 is considered unset.
// For bool, false is unset.
// Structs are never considered unset.
//
// For everything else, including pointers, a nil value is unset.
func dfault(d interface{}, given ...interface{}) interface{} <span class="cov4" title="5">{

        if empty(given) || empty(given[0]) </span><span class="cov3" title="3">{
                return d
        }</span>
        <span class="cov2" title="2">return given[0]</span>
}

// empty returns true if the given value has the zero value for its type.
func empty(given interface{}) bool <span class="cov10" title="52">{
        g := reflect.ValueOf(given)
        if !g.IsValid() </span><span class="cov6" title="12">{
                return true
        }</span>

        // Basically adapted from text/template.isTrue
        <span class="cov9" title="40">switch g.Kind() </span>{
        default:<span class="cov0" title="0">
                return g.IsNil()</span>
        case reflect.Array, reflect.Slice, reflect.Map, reflect.String:<span class="cov7" title="20">
                return g.Len() == 0</span>
        case reflect.Bool:<span class="cov0" title="0">
                return !g.Bool()</span>
        case reflect.Complex64, reflect.Complex128:<span class="cov0" title="0">
                return g.Complex() == 0</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov7" title="19">
                return g.Int() == 0</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:<span class="cov0" title="0">
                return g.Uint() == 0</span>
        case reflect.Float32, reflect.Float64:<span class="cov1" title="1">
                return g.Float() == 0</span>
        case reflect.Struct:<span class="cov0" title="0">
                return false</span>
        }
}

// coalesce returns the first non-empty value.
func coalesce(v ...interface{}) interface{} <span class="cov5" title="7">{
        for _, val := range v </span><span class="cov7" title="17">{
                if !empty(val) </span><span class="cov5" title="6">{
                        return val
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// all returns true if empty(x) is false for all values x in the list.
// If the list is empty, return true.
func all(v ...interface{}) bool <span class="cov5" title="7">{
        for _, val := range v </span><span class="cov5" title="6">{
                if empty(val) </span><span class="cov4" title="5">{
                        return false
                }</span>
        }
        <span class="cov2" title="2">return true</span>
}

// any returns true if empty(x) is false for any x in the list.
// If the list is empty, return false.
func any(v ...interface{}) bool <span class="cov5" title="7">{
        for _, val := range v </span><span class="cov7" title="20">{
                if !empty(val) </span><span class="cov4" title="5">{
                        return true
                }</span>
        }
        <span class="cov2" title="2">return false</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package template

import (
        "os"
        "sort"
        "strings"
        "text/template"
        "time"

        "github.com/lucasepe/yo/internal/wordutils"
        "github.com/lucasepe/yo/internal/xstrings"
)

type builtinFunction struct {
        fn      interface{}
        summary string
        usage   string
}

var functionsMap = map[string]builtinFunction{
        // Date functions
        "ago": {
                fn:      dateAgo,
                summary: "Returns duration from time.Now in seconds resolution.",
                usage:   "ago .CreatedAt",
        },
        "date": {
                fn:      date,
                summary: "Formats a date.",
                usage:   `now | date "2006-01-02"`,
        },
        "dateInZone": {
                fn:      dateInZone,
                summary: "Same as date, but with a timezone.",
                usage:   `dateInZone "2006-01-02" (now) "UTC"`,
        },
        "dateModify": {
                fn:      dateModify,
                summary: "Takes a modification and a date and returns the timestamp.",
                usage:   `now | dateModify "-1.5h"`,
        },
        "duration": {
                fn:      duration,
                summary: "Formats a given amount of seconds as a time.Duration.",
                usage:   "duration 95",
        },
        "now": {
                fn:      time.Now,
                summary: "The current date/time. Use this in conjunction with other date functions.",
                usage:   `now | date "2006-01-02"`,
        },
        "toDate": {
                fn:      toDate,
                summary: "Converts a string to a date.",
                usage:   `toDate "2006-01-02" "2017-12-31" | date "02/01/2006"`,
        },
        "unixEpoch": {
                fn:      unixEpoch,
                summary: "Returns the seconds since the unix epoch for a time.Time.",
                usage:   "now | unixEpoch",
        },

        // String functions
        "trim": {
                fn:      strings.TrimSpace,
                summary: "Removes space from either side of a string.",
                usage:   `trim "   hello    "`,
        },
        "trimAll": {
                fn:      func(a, b string) string <span class="cov1" title="1">{ return strings.Trim(b, a) }</span>,
                summary: "Remove given characters from the front or back of a string.",
                usage:   `trimAll "$" "$5.00$"`,
        },
        "trimSuffix": {
                fn:      func(a, b string) string <span class="cov1" title="1">{ return strings.TrimSuffix(b, a) }</span>,
                summary: "Trim just the suffix from a string.",
                usage:   `trimSuffix "-" "hello-"`,
        },
        "trimPrefix": {
                fn:      func(a, b string) string <span class="cov1" title="1">{ return strings.TrimPrefix(b, a) }</span>,
                summary: "Trim just the prefix from a string.",
                usage:   `trimPrefix "-" "-hello"`,
        },
        "upper": {
                fn:      strings.ToUpper,
                summary: "Convert the entire string to uppercase.",
                usage:   `upper "hello"`,
        },
        "lower": {
                fn:      strings.ToLower,
                summary: "Convert the entire string to lowercase.",
                usage:   `lower "HELLO"`,
        },
        "title": {
                fn:      strings.Title,
                summary: "Convert to title case.",
                usage:   `title "hello world"`,
        },
        "untitle": {
                fn:      untitle,
                summary: "Remove title casing.",
                usage:   `untitle "Hello World"`,
        },
        // Switch order so that "foo" | repeat 5
        "repeat": {
                fn:      func(count int, str string) string <span class="cov0" title="0">{ return strings.Repeat(str, count) }</span>,
                summary: "Repeat a string multiple times.",
                usage:   `repeat 3 "hello"`,
        },
        "substr": {
                fn:      substring,
                summary: "Get a substring from a string.",
                usage:   `substr 0 5 "hello world"`,
        },
        "trunc": {
                fn:      trunc,
                summary: "Truncate a string.",
                usage:   `trunc -5 "hello world"`,
        },
        "initials": {
                fn:      initials,
                summary: "Take the first letter of each word and combine.",
                usage:   `initials "Hello World"`,
        },
        "contains": {
                fn:      func(substr string, str string) bool <span class="cov1" title="1">{ return strings.Contains(str, substr) }</span>,
                summary: "Test to see if one string is contained inside of another.",
                usage:   `contains "cat" "catch"`,
        },
        "hasPrefix": {
                fn:      func(substr string, str string) bool <span class="cov1" title="1">{ return strings.HasPrefix(str, substr) }</span>,
                summary: "Test whether a string has a given prefix.",
                usage:   `hasPrefix "cat" "catch"`,
        },
        "hasSuffix": {
                fn:      func(substr string, str string) bool <span class="cov1" title="1">{ return strings.HasSuffix(str, substr) }</span>,
                summary: "Test whether a string has a given suffix.",
                usage:   `hasSuffix "tch" "catch"`,
        },
        "quote": {
                fn:      quote,
                summary: "Wrap a string in double quotes.",
                usage:   `quote "Hello"`,
        },
        "squote": {
                fn:      squote,
                summary: "Wrap a string in single quotes.",
                usage:   `squote "Hello"`,
        },
        "split": {
                fn:      func(sep, orig string) []string <span class="cov1" title="1">{ return strings.Split(orig, sep) }</span>,
                summary: "Split a string into a list of strings.",
                usage:   `split "$" "foo$bar$baz$bar"`,
        },
        "join": {
                fn:      join,
                summary: "Join a list of strings into a single string, with the given separator.",
                usage:   `join "-" .Names`,
        },
        "list": {
                fn:      list,
                summary: "Create a list of data.",
                usage:   `list "tmp" "pippo" "file.txt"`,
        },
        "cat": {
                fn:      cat,
                summary: "Concatenates strings together, separating them with spaces.",
                usage:   `cat "hello" "beautiful" "world"`,
        },
        "replace": {
                fn:      replace,
                summary: "Perform simple string replacement.",
                usage:   `"I Am Henry VIII" | replace " " "-"`,
        },
        "swapcase": {
                fn:      wordutils.SwapCase,
                summary: "Swap the case of a string using a word based algorithm.",
                usage:   `swapcase "This Is A.Test"`,
        },
        "snakecase": {
                fn:      xstrings.ToSnakeCase,
                summary: "Convert string from camelCase to snake_case.",
                usage:   `snakecase "FirstName"`,
        },
        "camelcase": {
                fn:      xstrings.ToCamelCase,
                summary: "Convert string from snake_case to CamelCase.",
                usage:   `camelcase "http_server"`,
        },
        "kebabcase": {
                fn:      xstrings.ToKebabCase,
                summary: "Convert string from camelCase to kebab-case.",
                usage:   `kebabcase "FirstName"`,
        },
        "regexMatch": {
                fn:      regexMatch,
                summary: "Test if the input string matches a regular expression.",
                usage:   `regexMatch "^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$" "test@acme.com"`,
        },
        "regexFindAll": {
                fn:      regexFindAll,
                summary: "Returns a slice of all matches of the regular expression in the input string.",
                usage:   `regexFindAll "[2,4,6,8]" "123456789" -1`,
        },
        "regexFind": {
                fn:      regexFind,
                summary: "Return the first match of the regular expression in the input string.",
                usage:   `regexFind "[a-zA-Z][1-9]" "abcd1234"`,
        },
        "regexReplaceAll": {
                fn:      regexReplaceAll,
                summary: "Replace matches of the regexp with the specified string.\nInside string replacement, $ signs are interpreted as in Expand, so for instance $1 represents the text of the first submatch.",
                usage:   `regexReplaceAll "a(x*)b" "-ab-axxb-" "${1}W"`,
        },
        "regexReplaceAllLiteral": {
                fn:      regexReplaceAllLiteral,
                summary: "Replace matches of the regexp with the specified string.\nThe replacement string is substituted directly, without using expansion.",
                usage:   `regexReplaceAllLiteral "a(x*)b" "-ab-axxb-" "${1}"`,
        },
        "regexSplit": {
                fn:      regexSplit,
                summary: "Slices the input string into substrings separated by the expression and returns a slice of the substrings between those expression matches. The last parameter n determines the number of substrings to return, where -1 means return all matches.",
                usage:   `regexSplit "z+" "pizza" -1`,
        },
        "regexQuoteMeta": {
                fn:      regexQuoteMeta,
                summary: "Returns a string that escapes all regular expression metacharacters inside the argument text; the returned string is a regular expression matching the literal text.",
                usage:   `regexQuoteMeta "1.2.3"`,
        },
        // OS:
        "env": {
                fn:      os.Getenv,
                summary: "Reads an environment variable.",
                usage:   `env "HOME"`,
        },
        "expandenv": {
                fn:      os.ExpandEnv,
                summary: "Substitute environment variables in a string.",
                usage:   `expandenv "Your path is set to $PATH"`,
        },
        "pathSep": {
                fn:      func() string <span class="cov0" title="0">{ return string(os.PathSeparator) }</span>,
                summary: "Returns OS-specific path separator.",
                usage:   `pathSep`,
        },
        "pathListSep": {
                fn:      func() string <span class="cov0" title="0">{ return string(os.PathListSeparator) }</span>,
                summary: "Returns OS-specific path list separator.",
                usage:   `pathSep`,
        },
        "tempDir": {
                fn:      os.TempDir,
                summary: "Returns the default directory to use for temporary files.",
                usage:   `tempDir`,
        },
        // UUIDs:
        "uuid": {
                fn:      uuidv4,
                summary: "Generate UUID v4 universally unique IDs.",
                usage:   `uuidv4`,
        },
        "sha1sum": {
                fn:      sha1sum,
                summary: "Computes the SHA1 digest of a specified string",
                usage:   `sha1sum "Hello world!"`,
        },
        "sha256sum": {
                fn:      sha256sum,
                summary: "Computes the SHA256 digest of a specified string",
                usage:   `sha256sum "Hello world!"`,
        },
        // Encoding:
        "b64enc": {
                fn:      base64encode,
                summary: "Encode or decode with Base64",
                usage:   `b64enc "Hello world!"`,
        },
        "b64dec": {
                fn:      base64decode,
                summary: "Decode with Base64",
                usage:   `b64dec "Hello world!"`,
        },
        "b32enc": {
                fn:      base32encode,
                summary: "Encode with Base32",
                usage:   `b32enc "Hello world!"`,
        },
        "b32dec": {
                fn:      base32decode,
                summary: "Decode with Base32",
                usage:   `b32dec "Hello world!"`,
        },
        // Defaults
        "default": {
                fn:      dfault,
                summary: "Set a simple default value.",
                usage:   `default "foo" .Bar`,
        },
        "coalesce": {
                fn:      coalesce,
                summary: "Takes a list of values and returns the first non-empty one.",
                usage:   `coalesce .name .parent.name "Scarlett"`,
        },

        "all": {
                fn:      all,
                summary: "Takes a list of values and returns true if all values are non-empty.",
                usage:   `all (.Request.ProtoAtLeast 2 0) (eq .Request.Method "POST")`,
        },
        "any": {
                fn:      any,
                summary: "Takes a list of values and returns true if any value is non-empty.",
                usage:   `any (eq .Request.Method "GET") (eq .Request.Method "POST")`,
        },
        "until": {
                fn:      until,
                summary: "Builds a range of integers.",
                usage:   `until 5`,
        },
        "untilStep": {
                fn:      untilStep,
                summary: "Generates a list of integers. It allows you to define a start, stop, and step.",
                usage:   `untilStep 3 6 2`,
        },
        "seq": {
                fn:      seq,
                summary: "Like the bash seq command.",
                usage:   `seq 0 -2 -5`,
        },
        "incr": {
                fn:      func(i interface{}) int64 <span class="cov1" title="1">{ return toInt64(i) + 1 }</span>,
                summary: "Increment an integer value by one.",
                usage:   `incr 7`,
        },
        "decr": {
                fn:      func(i interface{}) int64 <span class="cov1" title="1">{ return toInt64(i) - 1 }</span>,
                summary: "Decrement an integer value by one.",
                usage:   `decr 9`,
        },
        "rand": {
                fn:      randInt,
                summary: "Returns a random integer value from min (inclusive) to max (exclusive).",
                usage:   `rand 8 16`,
        },
        // List
        "has": {
                fn:      has,
                summary: "Test to see if a list has a particular element.",
                usage:   `has 4 $myList`,
        },
        "uniq": {
                fn:      uniq,
                summary: "Generate a list with all of the duplicates removed.",
                usage:   `{{ .MyList | uniq }}`,
        },
}

// Names returns the builtin functions names.
func Names() []string <span class="cov0" title="0">{
        var res []string
        for k := range functionsMap </span><span class="cov0" title="0">{
                res = append(res, k)
        }</span>
        <span class="cov0" title="0">sort.Strings(res)
        return res</span>
}

// Summary return the specific builtin function description.
func Summary(name string) string <span class="cov0" title="0">{
        res, ok := functionsMap[name]
        if ok </span><span class="cov0" title="0">{
                return res.summary
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Usage return the specific builtin function usage.
func Usage(name string) string <span class="cov0" title="0">{
        res, ok := functionsMap[name]
        if ok </span><span class="cov0" title="0">{
                return res.usage
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// TxtFuncMap returns a 'text/template'.FuncMap
func TxtFuncMap() template.FuncMap <span class="cov5" title="134">{
        fm := make(map[string]interface{}, len(functionsMap))
        for k, v := range functionsMap </span><span class="cov10" title="8710">{
                fm[k] = v.fn
        }</span>

        <span class="cov5" title="134">return template.FuncMap(fm)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package template

import (
        "fmt"
        "reflect"
)

func list(v ...interface{}) []interface{} <span class="cov1" title="1">{
        return v
}</span>

func has(needle interface{}, haystack interface{}) (bool, error) <span class="cov4" title="4">{
        if haystack == nil </span><span class="cov1" title="1">{
                return false, nil
        }</span>
        <span class="cov3" title="3">tp := reflect.TypeOf(haystack).Kind()
        switch tp </span>{
        case reflect.Slice, reflect.Array:<span class="cov3" title="3">
                l2 := reflect.ValueOf(haystack)
                var item interface{}
                l := l2.Len()
                for i := 0; i &lt; l; i++ </span><span class="cov5" title="6">{
                        item = l2.Index(i).Interface()
                        if reflect.DeepEqual(needle, item) </span><span class="cov2" title="2">{
                                return true, nil
                        }</span>
                }

                <span class="cov1" title="1">return false, nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("cannot find has on type %s", tp)</span>
        }
}

func uniq(list interface{}) ([]interface{}, error) <span class="cov3" title="3">{
        tp := reflect.TypeOf(list).Kind()
        switch tp </span>{
        case reflect.Slice, reflect.Array:<span class="cov3" title="3">
                l2 := reflect.ValueOf(list)

                l := l2.Len()
                dest := []interface{}{}
                var item interface{}
                for i := 0; i &lt; l; i++ </span><span class="cov8" title="19">{
                        item = l2.Index(i).Interface()
                        if !inList(dest, item) </span><span class="cov7" title="10">{
                                dest = append(dest, item)
                        }</span>
                }

                <span class="cov3" title="3">return dest, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("cannot find uniq on type %s", tp)</span>
        }
}

func inList(haystack []interface{}, needle interface{}) bool <span class="cov8" title="19">{
        for _, h := range haystack </span><span class="cov10" title="31">{
                if reflect.DeepEqual(needle, h) </span><span class="cov6" title="9">{
                        return true
                }</span>
        }
        <span class="cov7" title="10">return false</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package template

import (
        crypto_rand "crypto/rand"
        "encoding/binary"
        "fmt"
        math_rand "math/rand"
        "strings"
        "time"

        "github.com/lucasepe/yo/internal/cast"
)

func init() <span class="cov1" title="1">{
        var b [8]byte
        _, err := crypto_rand.Read(b[:])
        if err != nil </span><span class="cov0" title="0">{
                math_rand.Seed(time.Now().UnixNano())
        }</span> else<span class="cov1" title="1"> {
                math_rand.Seed(int64(binary.LittleEndian.Uint64(b[:])))
        }</span>
}

func randInt(min, max int) int <span class="cov4" title="4">{
        return math_rand.Intn(max-min) + min
}</span>

// toInt64 converts integer types to 64-bit integers
func toInt64(v interface{}) int64 <span class="cov7" title="13">{
        return cast.ToInt64(v)
}</span>

func until(count int) []int <span class="cov2" title="2">{
        step := 1
        if count &lt; 0 </span><span class="cov1" title="1">{
                step = -1
        }</span>
        <span class="cov2" title="2">return untilStep(0, count, step)</span>
}

func untilStep(start, stop, step int) []int <span class="cov8" title="17">{
        v := []int{}

        if stop &lt; start </span><span class="cov6" title="8">{
                if step &gt;= 0 </span><span class="cov2" title="2">{
                        return v
                }</span>
                <span class="cov5" title="6">for i := start; i &gt; stop; i += step </span><span class="cov9" title="25">{
                        v = append(v, i)
                }</span>
                <span class="cov5" title="6">return v</span>
        }

        <span class="cov6" title="9">if step &lt;= 0 </span><span class="cov2" title="2">{
                return v
        }</span>
        <span class="cov6" title="7">for i := start; i &lt; stop; i += step </span><span class="cov10" title="31">{
                v = append(v, i)
        }</span>
        <span class="cov6" title="7">return v</span>
}

func seq(params ...int) string <span class="cov7" title="11">{
        increment := 1
        switch len(params) </span>{
        case 0:<span class="cov1" title="1">
                return ""</span>
        case 1:<span class="cov3" title="3">
                start := 1
                end := params[0]
                if end &lt; start </span><span class="cov2" title="2">{
                        increment = -1
                }</span>
                <span class="cov3" title="3">return intArrayToString(untilStep(start, end+increment, increment), " ")</span>
        case 3:<span class="cov4" title="4">
                start := params[0]
                end := params[2]
                step := params[1]
                if end &lt; start </span><span class="cov2" title="2">{
                        increment = -1
                        if step &gt; 0 </span><span class="cov1" title="1">{
                                return ""
                        }</span>
                }
                <span class="cov3" title="3">return intArrayToString(untilStep(start, end+increment, step), " ")</span>
        case 2:<span class="cov2" title="2">
                start := params[0]
                end := params[1]
                step := 1
                if end &lt; start </span><span class="cov1" title="1">{
                        step = -1
                }</span>
                <span class="cov2" title="2">return intArrayToString(untilStep(start, end+step, step), " ")</span>
        default:<span class="cov1" title="1">
                return ""</span>
        }
}

func intArrayToString(slice []int, delimeter string) string <span class="cov6" title="8">{
        return strings.Trim(strings.Join(strings.Fields(fmt.Sprint(slice)), delimeter), "[]")
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package template

import (
        "regexp"
)

func regexMatch(regex string, s string) (bool, error) <span class="cov7" title="5">{
        return regexp.MatchString(regex, s)
}</span>

func regexFindAll(regex string, s string, n int) ([]string, error) <span class="cov6" title="4">{
        r, err := regexp.Compile(regex)
        if err != nil </span><span class="cov0" title="0">{
                return []string{}, err
        }</span>
        <span class="cov6" title="4">return r.FindAllString(s, n), nil</span>
}

func regexFind(regex string, s string) (string, error) <span class="cov5" title="3">{
        r, err := regexp.Compile(regex)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov5" title="3">return r.FindString(s), nil</span>
}

func regexReplaceAll(regex string, s string, repl string) (string, error) <span class="cov6" title="4">{
        r, err := regexp.Compile(regex)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov6" title="4">return r.ReplaceAllString(s, repl), nil</span>
}

func regexReplaceAllLiteral(regex string, s string, repl string) (string, error) <span class="cov5" title="3">{
        r, err := regexp.Compile(regex)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov5" title="3">return r.ReplaceAllLiteralString(s, repl), nil</span>
}

func regexSplit(regex string, s string, n int) ([]string, error) <span class="cov10" title="10">{
        r, err := regexp.Compile(regex)
        if err != nil </span><span class="cov0" title="0">{
                return []string{}, err
        }</span>
        <span class="cov10" title="10">return r.Split(s, n), nil</span>
}

func regexQuoteMeta(s string) string <span class="cov6" title="4">{
        return regexp.QuoteMeta(s)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package template

import (
        "encoding/base32"
        "encoding/base64"
        "fmt"
        "reflect"
        "strings"

        "github.com/lucasepe/yo/internal/wordutils"
)

func base64encode(v string) string <span class="cov1" title="1">{
        return base64.StdEncoding.EncodeToString([]byte(v))
}</span>

func base64decode(v string) string <span class="cov1" title="1">{
        data, err := base64.StdEncoding.DecodeString(v)
        if err != nil </span><span class="cov0" title="0">{
                return err.Error()
        }</span>
        <span class="cov1" title="1">return string(data)</span>
}

func base32encode(v string) string <span class="cov1" title="1">{
        return base32.StdEncoding.EncodeToString([]byte(v))
}</span>

func base32decode(v string) string <span class="cov1" title="1">{
        data, err := base32.StdEncoding.DecodeString(v)
        if err != nil </span><span class="cov0" title="0">{
                return err.Error()
        }</span>
        <span class="cov1" title="1">return string(data)</span>
}

func initials(s string) string <span class="cov1" title="1">{
        // Wrap this just to eliminate the var args, which templates don't do well.
        return wordutils.Initials(s)
}</span>

func untitle(str string) string <span class="cov1" title="1">{
        return wordutils.Uncapitalize(str)
}</span>

func quote(str ...interface{}) string <span class="cov5" title="4">{
        out := make([]string, 0, len(str))
        for _, s := range str </span><span class="cov8" title="10">{
                if s != nil </span><span class="cov8" title="9">{
                        out = append(out, fmt.Sprintf("%q", strval(s)))
                }</span>
        }
        <span class="cov5" title="4">return strings.Join(out, " ")</span>
}

func squote(str ...interface{}) string <span class="cov4" title="3">{
        out := make([]string, 0, len(str))
        for _, s := range str </span><span class="cov7" title="7">{
                if s != nil </span><span class="cov6" title="6">{
                        out = append(out, fmt.Sprintf("'%v'", s))
                }</span>
        }
        <span class="cov4" title="3">return strings.Join(out, " ")</span>
}

func cat(v ...interface{}) string <span class="cov3" title="2">{
        v = removeNilElements(v)
        r := strings.TrimSpace(strings.Repeat("%v ", len(v)))
        return fmt.Sprintf(r, v...)
}</span>

func replace(old, new, src string) string <span class="cov1" title="1">{
        return strings.Replace(src, old, new, -1)
}</span>

func strslice(v interface{}) []string <span class="cov5" title="4">{
        switch v := v.(type) </span>{
        case []string:<span class="cov1" title="1">
                return v</span>
        case []interface{}:<span class="cov1" title="1">
                b := make([]string, 0, len(v))
                for _, s := range v </span><span class="cov4" title="3">{
                        if s != nil </span><span class="cov3" title="2">{
                                b = append(b, strval(s))
                        }</span>
                }
                <span class="cov1" title="1">return b</span>
        default:<span class="cov3" title="2">
                val := reflect.ValueOf(v)
                switch val.Kind() </span>{
                case reflect.Array, reflect.Slice:<span class="cov1" title="1">
                        l := val.Len()
                        b := make([]string, 0, l)
                        for i := 0; i &lt; l; i++ </span><span class="cov4" title="3">{
                                value := val.Index(i).Interface()
                                if value != nil </span><span class="cov4" title="3">{
                                        b = append(b, strval(value))
                                }</span>
                        }
                        <span class="cov1" title="1">return b</span>
                default:<span class="cov1" title="1">
                        if v == nil </span><span class="cov0" title="0">{
                                return []string{}
                        }</span>

                        <span class="cov1" title="1">return []string{strval(v)}</span>
                }
        }
}

func removeNilElements(v []interface{}) []interface{} <span class="cov3" title="2">{
        newSlice := make([]interface{}, 0, len(v))
        for _, i := range v </span><span class="cov6" title="6">{
                if i != nil </span><span class="cov6" title="5">{
                        newSlice = append(newSlice, i)
                }</span>
        }
        <span class="cov3" title="2">return newSlice</span>
}

func strval(v interface{}) string <span class="cov10" title="15">{
        switch v := v.(type) </span>{
        case string:<span class="cov8" title="9">
                return v</span>
        case []byte:<span class="cov0" title="0">
                return string(v)</span>
        case error:<span class="cov0" title="0">
                return v.Error()</span>
        case fmt.Stringer:<span class="cov0" title="0">
                return v.String()</span>
        default:<span class="cov6" title="6">
                return fmt.Sprintf("%v", v)</span>
        }
}

func trunc(c int, s string) string <span class="cov5" title="4">{
        if c &lt; 0 &amp;&amp; len(s)+c &gt; 0 </span><span class="cov1" title="1">{
                return s[len(s)+c:]
        }</span>
        <span class="cov4" title="3">if c &gt;= 0 &amp;&amp; len(s) &gt; c </span><span class="cov3" title="2">{
                return s[:c]
        }</span>
        <span class="cov1" title="1">return s</span>
}

func join(sep string, v interface{}) string <span class="cov5" title="4">{
        return strings.Join(strslice(v), sep)
}</span>

// substring creates a substring of the given string.
//
// If start is &lt; 0, this calls string[:end].
//
// If start is &gt;= 0 and end &lt; 0 or end bigger than s length, this calls string[start:]
//
// Otherwise, this calls string[start, end].
func substring(start, end int, s string) string <span class="cov3" title="2">{
        if start &lt; 0 </span><span class="cov0" title="0">{
                return s[:end]
        }</span>
        <span class="cov3" title="2">if end &lt; 0 || end &gt; len(s) </span><span class="cov1" title="1">{
                return s[start:]
        }</span>
        <span class="cov1" title="1">return s[start:end]</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package template

import (
        "bytes"
        "text/template"
)

func ExecuteInline(data interface{}, s string) ([]byte, error) <span class="cov0" title="0">{
        // Build function map.
        funcMap := TxtFuncMap()

        // Build the template
        t := template.New("main")
        t.Funcs(funcMap)

        _, err := t.Parse(s)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var buf bytes.Buffer
        if err := t.Execute(&amp;buf, data); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package wordutils

/*
Copyright 2014 Alexander Okoli

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

import (
        "bytes"
        "strings"
        "unicode"
)

/*
Wrap wraps a single line of text, identifying words by ' '.
New lines will be separated by '\n'. Very long words, such as URLs will not be wrapped.
Leading spaces on a new line are stripped. Trailing spaces are not stripped.

Parameters:
    str - the string to be word wrapped
    wrapLength - the column (a column can fit only one character) to wrap the words at, less than 1 is treated as 1

Returns:
    a line with newlines inserted
*/
func Wrap(str string, wrapLength int) string <span class="cov3" title="5">{
        return WrapCustom(str, wrapLength, "", false)
}</span>

/*
WrapCustom wraps a single line of text, identifying words by ' '.
Leading spaces on a new line are stripped. Trailing spaces are not stripped.

Parameters:
    str - the string to be word wrapped
    wrapLength - the column number (a column can fit only one character) to wrap the words at, less than 1 is treated as 1
    newLineStr - the string to insert for a new line, "" uses '\n'
    wrapLongWords - true if long words (such as URLs) should be wrapped

Returns:
    a line with newlines inserted
*/
func WrapCustom(str string, wrapLength int, newLineStr string, wrapLongWords bool) string <span class="cov4" title="9">{

        if str == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov4" title="9">if newLineStr == "" </span><span class="cov3" title="5">{
                newLineStr = "\n" // TODO Assumes "\n" is seperator. Explore SystemUtils.LINE_SEPARATOR from Apache Commons
        }</span>
        <span class="cov4" title="9">if wrapLength &lt; 1 </span><span class="cov0" title="0">{
                wrapLength = 1
        }</span>

        <span class="cov4" title="9">inputLineLength := len(str)
        offset := 0

        var wrappedLine bytes.Buffer

        for inputLineLength-offset &gt; wrapLength </span><span class="cov5" title="19">{

                if rune(str[offset]) == ' ' </span><span class="cov0" title="0">{
                        offset++
                        continue</span>
                }

                <span class="cov5" title="19">end := wrapLength + offset + 1
                spaceToWrapAt := strings.LastIndex(str[offset:end], " ") + offset

                if spaceToWrapAt &gt;= offset </span><span class="cov4" title="10">{
                        // normal word (not longer than wrapLength)
                        wrappedLine.WriteString(str[offset:spaceToWrapAt])
                        wrappedLine.WriteString(newLineStr)
                        offset = spaceToWrapAt + 1

                }</span> else<span class="cov4" title="9"> {
                        // long word or URL
                        if wrapLongWords </span><span class="cov3" title="5">{
                                end := wrapLength + offset
                                // long words are wrapped one line at a time
                                wrappedLine.WriteString(str[offset:end])
                                wrappedLine.WriteString(newLineStr)
                                offset += wrapLength
                        }</span> else<span class="cov3" title="4"> {
                                // long words aren't wrapped, just extended beyond limit
                                end := wrapLength + offset
                                index := strings.IndexRune(str[end:], ' ')
                                if index == -1 </span><span class="cov2" title="2">{
                                        wrappedLine.WriteString(str[offset:])
                                        offset = inputLineLength
                                }</span> else<span class="cov2" title="2"> {
                                        spaceToWrapAt = index + end
                                        wrappedLine.WriteString(str[offset:spaceToWrapAt])
                                        wrappedLine.WriteString(newLineStr)
                                        offset = spaceToWrapAt + 1
                                }</span>
                        }
                }
        }

        <span class="cov4" title="9">wrappedLine.WriteString(str[offset:])

        return wrappedLine.String()</span>

}

/*
Capitalize capitalizes all the delimiter separated words in a string. Only the first letter of each word is changed.
To convert the rest of each word to lowercase at the same time, use CapitalizeFully(str string, delimiters ...rune).
The delimiters represent a set of characters understood to separate words. The first string character
and the first non-delimiter character after a delimiter will be capitalized. A "" input string returns "".
Capitalization uses the Unicode title case, normally equivalent to upper case.

Parameters:
    str - the string to capitalize
    delimiters - set of characters to determine capitalization, exclusion of this parameter means whitespace would be delimeter

Returns:
    capitalized string
*/
func Capitalize(str string, delimiters ...rune) string <span class="cov4" title="8">{

        var delimLen int

        if delimiters == nil </span><span class="cov3" title="4">{
                delimLen = -1
        }</span> else<span class="cov3" title="4"> {
                delimLen = len(delimiters)
        }</span>

        <span class="cov4" title="8">if str == "" || delimLen == 0 </span><span class="cov0" title="0">{
                return str
        }</span>

        <span class="cov4" title="8">buffer := []rune(str)
        capitalizeNext := true
        for i := 0; i &lt; len(buffer); i++ </span><span class="cov9" title="336">{
                ch := buffer[i]
                if isDelimiter(ch, delimiters...) </span><span class="cov6" title="40">{
                        capitalizeNext = true
                }</span> else<span class="cov9" title="296"> if capitalizeNext </span><span class="cov6" title="48">{
                        buffer[i] = unicode.ToTitle(ch)
                        capitalizeNext = false
                }</span>
        }
        <span class="cov4" title="8">return string(buffer)</span>

}

/*
CapitalizeFully converts all the delimiter separated words in a string into capitalized words, that is each word is made up of a
titlecase character and then a series of lowercase characters. The delimiters represent a set of characters understood
to separate words. The first string character and the first non-delimiter character after a delimiter will be capitalized.
Capitalization uses the Unicode title case, normally equivalent to upper case.

Parameters:
    str - the string to capitalize fully
    delimiters - set of characters to determine capitalization, exclusion of this parameter means whitespace would be delimeter

Returns:
    capitalized string
*/
func CapitalizeFully(str string, delimiters ...rune) string <span class="cov3" title="4">{

        var delimLen int

        if delimiters == nil </span><span class="cov2" title="2">{
                delimLen = -1
        }</span> else<span class="cov2" title="2"> {
                delimLen = len(delimiters)
        }</span>

        <span class="cov3" title="4">if str == "" || delimLen == 0 </span><span class="cov0" title="0">{
                return str
        }</span>
        <span class="cov3" title="4">str = strings.ToLower(str)
        return Capitalize(str, delimiters...)</span>
}

/*
Uncapitalize uncapitalizes all the whitespace separated words in a string. Only the first letter of each word is changed.
The delimiters represent a set of characters understood to separate words. The first string character and the first non-delimiter
character after a delimiter will be uncapitalized. Whitespace is defined by unicode.IsSpace(char).

Parameters:
    str - the string to uncapitalize fully
    delimiters - set of characters to determine capitalization, exclusion of this parameter means whitespace would be delimeter

Returns:
    uncapitalized string
*/
func Uncapitalize(str string, delimiters ...rune) string <span class="cov3" title="4">{

        var delimLen int

        if delimiters == nil </span><span class="cov2" title="2">{
                delimLen = -1
        }</span> else<span class="cov2" title="2"> {
                delimLen = len(delimiters)
        }</span>

        <span class="cov3" title="4">if str == "" || delimLen == 0 </span><span class="cov0" title="0">{
                return str
        }</span>

        <span class="cov3" title="4">buffer := []rune(str)
        uncapitalizeNext := true // TODO Always makes capitalize/un apply to first char.
        for i := 0; i &lt; len(buffer); i++ </span><span class="cov6" title="56">{
                ch := buffer[i]
                if isDelimiter(ch, delimiters...) </span><span class="cov4" title="10">{
                        uncapitalizeNext = true
                }</span> else<span class="cov6" title="46"> if uncapitalizeNext </span><span class="cov4" title="14">{
                        buffer[i] = unicode.ToLower(ch)
                        uncapitalizeNext = false
                }</span>
        }
        <span class="cov3" title="4">return string(buffer)</span>
}

/*
SwapCase swaps the case of a string using a word based algorithm.

Conversion algorithm:

    Upper case character converts to Lower case
    Title case character converts to Lower case
    Lower case character after Whitespace or at start converts to Title case
    Other Lower case character converts to Upper case
    Whitespace is defined by unicode.IsSpace(char).

Parameters:
    str - the string to swap case

Returns:
    the changed string
*/
func SwapCase(str string) string <span class="cov2" title="2">{
        if str == "" </span><span class="cov0" title="0">{
                return str
        }</span>
        <span class="cov2" title="2">buffer := []rune(str)

        whitespace := true

        for i := 0; i &lt; len(buffer); i++ </span><span class="cov5" title="28">{
                ch := buffer[i]
                if unicode.IsUpper(ch) </span><span class="cov4" title="8">{
                        buffer[i] = unicode.ToLower(ch)
                        whitespace = false
                }</span> else<span class="cov5" title="20"> if unicode.IsTitle(ch) </span><span class="cov0" title="0">{
                        buffer[i] = unicode.ToLower(ch)
                        whitespace = false
                }</span> else<span class="cov5" title="20"> if unicode.IsLower(ch) </span><span class="cov4" title="14">{
                        if whitespace </span><span class="cov0" title="0">{
                                buffer[i] = unicode.ToTitle(ch)
                                whitespace = false
                        }</span> else<span class="cov4" title="14"> {
                                buffer[i] = unicode.ToUpper(ch)
                        }</span>
                } else<span class="cov3" title="6"> {
                        whitespace = unicode.IsSpace(ch)
                }</span>
        }
        <span class="cov2" title="2">return string(buffer)</span>
}

/*
Initials extracts the initial letters from each word in the string. The first letter of the string and all first
letters after the defined delimiters are returned as a new string. Their case is not changed. If the delimiters
parameter is excluded, then Whitespace is used. Whitespace is defined by unicode.IsSpacea(char). An empty delimiter array returns an empty string.

Parameters:
    str - the string to get initials from
    delimiters - set of characters to determine words, exclusion of this parameter means whitespace would be delimeter
Returns:
    string of initial letters
*/
func Initials(str string, delimiters ...rune) string <span class="cov3" title="4">{
        if str == "" </span><span class="cov0" title="0">{
                return str
        }</span>
        <span class="cov3" title="4">if delimiters != nil &amp;&amp; len(delimiters) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov3" title="4">strLen := len(str)
        var buf bytes.Buffer
        lastWasGap := true
        for i := 0; i &lt; strLen; i++ </span><span class="cov6" title="48">{
                ch := rune(str[i])

                if isDelimiter(ch, delimiters...) </span><span class="cov3" title="6">{
                        lastWasGap = true
                }</span> else<span class="cov6" title="42"> if lastWasGap </span><span class="cov4" title="10">{
                        buf.WriteRune(ch)
                        lastWasGap = false
                }</span>
        }
        <span class="cov3" title="4">return buf.String()</span>
}

// private function (lower case func name)
func isDelimiter(ch rune, delimiters ...rune) bool <span class="cov10" title="440">{
        if delimiters == nil </span><span class="cov8" title="220">{
                return unicode.IsSpace(ch)
        }</span>
        <span class="cov8" title="220">for _, delimiter := range delimiters </span><span class="cov9" title="422">{
                if ch == delimiter </span><span class="cov6" title="38">{
                        return true
                }</span>
        }
        <span class="cov8" title="182">return false</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright 2015 Huan Du. All rights reserved.
// Licensed under the MIT license that can be found in the LICENSE file.

package xstrings

import (
        "strings"
        "unicode"
)

const bufferMaxInitGrowSize = 2048

// Lazy initialize a buffer.
func allocBuffer(orig, cur string) *strings.Builder <span class="cov6" title="34">{
        var output strings.Builder
        maxSize := len(orig) * 4

        // Avoid to reserve too much memory at once.
        if maxSize &gt; bufferMaxInitGrowSize </span><span class="cov0" title="0">{
                maxSize = bufferMaxInitGrowSize
        }</span>

        <span class="cov6" title="34">output.Grow(maxSize)
        output.WriteString(orig[:len(orig)-len(cur)])
        return &amp;output</span>
}

const minCJKCharacter = '\u3400'

// Checks r is a letter but not CJK character.
func isAlphabet(r rune) bool <span class="cov10" title="517">{
        if !unicode.IsLetter(r) </span><span class="cov8" title="134">{
                return false
        }</span>

        <span class="cov9" title="383">switch </span>{
        // Quick check for non-CJK character.
        case r &lt; minCJKCharacter:<span class="cov9" title="351">
                return true</span>

        // Common CJK characters.
        case r &gt;= '\u4E00' &amp;&amp; r &lt;= '\u9FCC':<span class="cov5" title="32">
                return false</span>

        // Rare CJK characters.
        case r &gt;= '\u3400' &amp;&amp; r &lt;= '\u4D85':<span class="cov0" title="0">
                return false</span>

        // Rare and historic CJK characters.
        case r &gt;= '\U00020000' &amp;&amp; r &lt;= '\U0002B81D':<span class="cov0" title="0">
                return false</span>
        }

        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright 2015 Huan Du. All rights reserved.
// Licensed under the MIT license that can be found in the LICENSE file.

package xstrings

import (
        "strings"
        "unicode"
        "unicode/utf8"
)

// ToCamelCase is to convert words separated by space, underscore and hyphen to camel case.
//
// Some samples.
//     "some_words"      =&gt; "SomeWords"
//     "http_server"     =&gt; "HttpServer"
//     "no_https"        =&gt; "NoHttps"
//     "_complex__case_" =&gt; "_Complex_Case_"
//     "some words"      =&gt; "SomeWords"
func ToCamelCase(str string) string <span class="cov4" title="12">{
        if len(str) == 0 </span><span class="cov1" title="1">{
                return ""
        }</span>

        <span class="cov4" title="11">var r0, r1 rune
        var size int

        buf := new(strings.Builder)

        // leading connector will appear in output.
        for len(str) &gt; 0 </span><span class="cov4" title="14">{
                r0, size = utf8.DecodeRuneInString(str)
                str = str[size:]

                if !isConnector(r0) </span><span class="cov4" title="11">{
                        r0 = unicode.ToUpper(r0)
                        break</span>
                }

                <span class="cov2" title="3">buf.WriteRune(r0)</span>
        }

        <span class="cov4" title="11">if len(str) == 0 </span><span class="cov1" title="2">{
                // A special case for a string contains only 1 rune.
                if size != 0 </span><span class="cov1" title="2">{
                        buf.WriteRune(r0)
                }</span>

                <span class="cov1" title="2">return buf.String()</span>
        }

        <span class="cov3" title="9">for len(str) &gt; 0 </span><span class="cov7" title="106">{
                r1 = r0
                r0, size = utf8.DecodeRuneInString(str)
                str = str[size:]

                if isConnector(r0) &amp;&amp; isConnector(r1) </span><span class="cov1" title="2">{
                        buf.WriteRune(r1)
                        continue</span>
                }

                <span class="cov7" title="104">if isConnector(r1) </span><span class="cov4" title="11">{
                        r0 = unicode.ToUpper(r0)
                }</span> else<span class="cov6" title="93"> {
                        r0 = unicode.ToLower(r0)
                        buf.WriteRune(r1)
                }</span>
        }

        <span class="cov3" title="9">buf.WriteRune(r0)
        return buf.String()</span>
}

// ToSnakeCase can convert all upper case characters in a string to
// snake case format.
//
// Some samples.
//     "FirstName"    =&gt; "first_name"
//     "HTTPServer"   =&gt; "http_server"
//     "NoHTTPS"      =&gt; "no_https"
//     "GO_PATH"      =&gt; "go_path"
//     "GO PATH"      =&gt; "go_path"  // space is converted to underscore.
//     "GO-PATH"      =&gt; "go_path"  // hyphen is converted to underscore.
//     "http2xx"      =&gt; "http_2xx" // insert an underscore before a number and after an alphabet.
//     "HTTP20xOK"    =&gt; "http_20x_ok"
//     "Duration2m3s" =&gt; "duration_2m3s"
//     "Bld4Floor3rd" =&gt; "bld4_floor_3rd"
func ToSnakeCase(str string) string <span class="cov5" title="31">{
        return camelCaseToLowerCase(str, '_')
}</span>

// ToKebabCase can convert all upper case characters in a string to
// kebab case format.
//
// Some samples.
//     "FirstName"    =&gt; "first-name"
//     "HTTPServer"   =&gt; "http-server"
//     "NoHTTPS"      =&gt; "no-https"
//     "GO_PATH"      =&gt; "go-path"
//     "GO PATH"      =&gt; "go-path"  // space is converted to '-'.
//     "GO-PATH"      =&gt; "go-path"  // hyphen is converted to '-'.
//     "http2xx"      =&gt; "http-2xx" // insert an underscore before a number and after an alphabet.
//     "HTTP20xOK"    =&gt; "http-20x-ok"
//     "Duration2m3s" =&gt; "duration-2m3s"
//     "Bld4Floor3rd" =&gt; "bld4-floor-3rd"
func ToKebabCase(str string) string <span class="cov5" title="31">{
        return camelCaseToLowerCase(str, '-')
}</span>

func camelCaseToLowerCase(str string, connector rune) string <span class="cov6" title="62">{
        if len(str) == 0 </span><span class="cov1" title="2">{
                return ""
        }</span>

        <span class="cov6" title="60">buf := new(strings.Builder)
        wt, word, remaining := nextWord(str)

        for len(remaining) &gt; 0 </span><span class="cov7" title="168">{
                if wt != connectorWord </span><span class="cov7" title="118">{
                        toLower(buf, wt, word, connector)
                }</span>

                <span class="cov7" title="168">prev := wt
                last := word
                wt, word, remaining = nextWord(remaining)

                switch prev </span>{
                case numberWord:<span class="cov3" title="6">
                        for wt == alphabetWord || wt == numberWord </span><span class="cov2" title="4">{
                                toLower(buf, wt, word, connector)
                                wt, word, remaining = nextWord(remaining)
                        }</span>

                        <span class="cov3" title="6">if wt != invalidWord &amp;&amp; wt != punctWord </span><span class="cov2" title="4">{
                                buf.WriteRune(connector)
                        }</span>

                case connectorWord:<span class="cov6" title="50">
                        toLower(buf, prev, last, connector)</span>

                case punctWord:<span class="cov3" title="10"></span>
                        // nothing.

                default:<span class="cov6" title="102">
                        if wt != numberWord </span><span class="cov6" title="78">{
                                if wt != connectorWord &amp;&amp; wt != punctWord </span><span class="cov5" title="26">{
                                        buf.WriteRune(connector)
                                }</span>

                                <span class="cov6" title="78">break</span>
                        }

                        <span class="cov5" title="24">if len(remaining) == 0 </span><span class="cov1" title="2">{
                                break</span>
                        }

                        <span class="cov4" title="22">last := word
                        wt, word, remaining = nextWord(remaining)

                        // consider number as a part of previous word.
                        // e.g. "Bld4Floor" =&gt; "bld4_floor"
                        if wt != alphabetWord </span><span class="cov3" title="8">{
                                toLower(buf, numberWord, last, connector)

                                if wt != connectorWord &amp;&amp; wt != punctWord </span><span class="cov3" title="6">{
                                        buf.WriteRune(connector)
                                }</span>

                                <span class="cov3" title="8">break</span>
                        }

                        // if there are some lower case letters following a number,
                        // add connector before the number.
                        // e.g. "HTTP2xx" =&gt; "http_2xx"
                        <span class="cov4" title="14">buf.WriteRune(connector)
                        toLower(buf, numberWord, last, connector)

                        for wt == alphabetWord || wt == numberWord </span><span class="cov5" title="26">{
                                toLower(buf, wt, word, connector)
                                wt, word, remaining = nextWord(remaining)
                        }</span>

                        <span class="cov4" title="14">if wt != invalidWord &amp;&amp; wt != connectorWord &amp;&amp; wt != punctWord </span><span class="cov3" title="6">{
                                buf.WriteRune(connector)
                        }</span>
                }
        }

        <span class="cov6" title="60">toLower(buf, wt, word, connector)
        return buf.String()</span>
}

func isConnector(r rune) bool <span class="cov10" title="1055">{
        return r == '-' || r == '_' || unicode.IsSpace(r)
}</span>

type wordType int

const (
        invalidWord wordType = iota
        numberWord
        upperCaseWord
        alphabetWord
        connectorWord
        punctWord
        otherWord
)

func nextWord(str string) (wt wordType, word, remaining string) <span class="cov8" title="280">{
        if len(str) == 0 </span><span class="cov3" title="10">{
                return
        }</span>

        <span class="cov8" title="270">var offset int
        remaining = str
        r, size := nextValidRune(remaining, utf8.RuneError)
        offset += size

        if r == utf8.RuneError </span><span class="cov1" title="2">{
                wt = invalidWord
                word = str[:offset]
                remaining = str[offset:]
                return
        }</span>

        <span class="cov8" title="268">switch </span>{
        case isConnector(r):<span class="cov6" title="56">
                wt = connectorWord
                remaining = remaining[size:]

                for len(remaining) &gt; 0 </span><span class="cov6" title="70">{
                        r, size = nextValidRune(remaining, r)

                        if !isConnector(r) </span><span class="cov6" title="50">{
                                break</span>
                        }

                        <span class="cov4" title="20">offset += size
                        remaining = remaining[size:]</span>
                }

        case unicode.IsPunct(r):<span class="cov4" title="12">
                wt = punctWord
                remaining = remaining[size:]

                for len(remaining) &gt; 0 </span><span class="cov4" title="14">{
                        r, size = nextValidRune(remaining, r)

                        if !unicode.IsPunct(r) </span><span class="cov3" title="10">{
                                break</span>
                        }

                        <span class="cov2" title="4">offset += size
                        remaining = remaining[size:]</span>
                }

        case unicode.IsUpper(r):<span class="cov6" title="94">
                wt = upperCaseWord
                remaining = remaining[size:]

                if len(remaining) == 0 </span><span class="cov3" title="6">{
                        break</span>
                }

                <span class="cov6" title="88">r, size = nextValidRune(remaining, r)

                switch </span>{
                case unicode.IsUpper(r):<span class="cov6" title="48">
                        prevSize := size
                        offset += size
                        remaining = remaining[size:]

                        for len(remaining) &gt; 0 </span><span class="cov7" title="134">{
                                r, size = nextValidRune(remaining, r)

                                if !unicode.IsUpper(r) </span><span class="cov5" title="32">{
                                        break</span>
                                }

                                <span class="cov6" title="102">prevSize = size
                                offset += size
                                remaining = remaining[size:]</span>
                        }

                        // it's a bit complex when dealing with a case like "HTTPStatus".
                        // it's expected to be splitted into "HTTP" and "Status".
                        // Therefore "S" should be in remaining instead of word.
                        <span class="cov6" title="48">if len(remaining) &gt; 0 &amp;&amp; isAlphabet(r) </span><span class="cov3" title="6">{
                                offset -= prevSize
                                remaining = str[offset:]
                        }</span>

                case isAlphabet(r):<span class="cov5" title="36">
                        offset += size
                        remaining = remaining[size:]

                        for len(remaining) &gt; 0 </span><span class="cov7" title="120">{
                                r, size = nextValidRune(remaining, r)

                                if !isAlphabet(r) || unicode.IsUpper(r) </span><span class="cov5" title="26">{
                                        break</span>
                                }

                                <span class="cov6" title="94">offset += size
                                remaining = remaining[size:]</span>
                        }
                }

        case isAlphabet(r):<span class="cov6" title="58">
                wt = alphabetWord
                remaining = remaining[size:]

                for len(remaining) &gt; 0 </span><span class="cov7" title="142">{
                        r, size = nextValidRune(remaining, r)

                        if !isAlphabet(r) || unicode.IsUpper(r) </span><span class="cov5" title="42">{
                                break</span>
                        }

                        <span class="cov6" title="100">offset += size
                        remaining = remaining[size:]</span>
                }

        case unicode.IsNumber(r):<span class="cov5" title="36">
                wt = numberWord
                remaining = remaining[size:]

                for len(remaining) &gt; 0 </span><span class="cov6" title="60">{
                        r, size = nextValidRune(remaining, r)

                        if !unicode.IsNumber(r) </span><span class="cov5" title="34">{
                                break</span>
                        }

                        <span class="cov5" title="26">offset += size
                        remaining = remaining[size:]</span>
                }

        default:<span class="cov4" title="12">
                wt = otherWord
                remaining = remaining[size:]

                for len(remaining) &gt; 0 </span><span class="cov5" title="24">{
                        r, size = nextValidRune(remaining, r)

                        if size == 0 || isConnector(r) || isAlphabet(r) || unicode.IsNumber(r) || unicode.IsPunct(r) </span><span class="cov4" title="12">{
                                break</span>
                        }

                        <span class="cov4" title="12">offset += size
                        remaining = remaining[size:]</span>
                }
        }

        <span class="cov8" title="268">word = str[:offset]
        return</span>
}

func nextValidRune(str string, prev rune) (r rune, size int) <span class="cov9" title="922">{
        var sz int

        for len(str) &gt; 0 </span><span class="cov9" title="950">{
                r, sz = utf8.DecodeRuneInString(str)
                size += sz

                if r != utf8.RuneError </span><span class="cov9" title="920">{
                        return
                }</span>

                <span class="cov5" title="30">str = str[sz:]</span>
        }

        <span class="cov1" title="2">r = prev
        return</span>
}

func toLower(buf *strings.Builder, wt wordType, str string, connector rune) <span class="cov8" title="280">{
        buf.Grow(buf.Len() + len(str))

        if wt != upperCaseWord &amp;&amp; wt != connectorWord </span><span class="cov7" title="130">{
                buf.WriteString(str)
                return
        }</span>

        <span class="cov7" title="150">for len(str) &gt; 0 </span><span class="cov8" title="454">{
                r, size := utf8.DecodeRuneInString(str)
                str = str[size:]

                if isConnector(r) </span><span class="cov6" title="76">{
                        buf.WriteRune(connector)
                }</span> else<span class="cov8" title="378"> if unicode.IsUpper(r) </span><span class="cov8" title="238">{
                        buf.WriteRune(unicode.ToLower(r))
                }</span> else<span class="cov7" title="140"> {
                        buf.WriteRune(r)
                }</span>
        }
}

// SwapCase will swap characters case from upper to lower or lower to upper.
func SwapCase(str string) string <span class="cov2" title="4">{
        var r rune
        var size int

        buf := new(strings.Builder)

        for len(str) &gt; 0 </span><span class="cov4" title="16">{
                r, size = utf8.DecodeRuneInString(str)

                switch </span>{
                case unicode.IsUpper(r):<span class="cov2" title="3">
                        buf.WriteRune(unicode.ToLower(r))</span>

                case unicode.IsLower(r):<span class="cov4" title="11">
                        buf.WriteRune(unicode.ToUpper(r))</span>

                default:<span class="cov1" title="2">
                        buf.WriteRune(r)</span>
                }

                <span class="cov4" title="16">str = str[size:]</span>
        }

        <span class="cov2" title="4">return buf.String()</span>
}

// FirstRuneToUpper converts first rune to upper case if necessary.
func FirstRuneToUpper(str string) string <span class="cov3" title="5">{
        if str == "" </span><span class="cov1" title="1">{
                return str
        }</span>

        <span class="cov2" title="4">r, size := utf8.DecodeRuneInString(str)

        if !unicode.IsLower(r) </span><span class="cov1" title="2">{
                return str
        }</span>

        <span class="cov1" title="2">buf := new(strings.Builder)
        buf.WriteRune(unicode.ToUpper(r))
        buf.WriteString(str[size:])
        return buf.String()</span>
}

// FirstRuneToLower converts first rune to lower case if necessary.
func FirstRuneToLower(str string) string <span class="cov3" title="6">{
        if str == "" </span><span class="cov1" title="1">{
                return str
        }</span>

        <span class="cov3" title="5">r, size := utf8.DecodeRuneInString(str)

        if !unicode.IsUpper(r) </span><span class="cov2" title="3">{
                return str
        }</span>

        <span class="cov1" title="2">buf := new(strings.Builder)
        buf.WriteRune(unicode.ToLower(r))
        buf.WriteString(str[size:])
        return buf.String()</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Copyright 2015 Huan Du. All rights reserved.
// Licensed under the MIT license that can be found in the LICENSE file.

package xstrings

import (
        "unicode/utf8"
)

// Len returns str's utf8 rune length.
func Len(str string) int <span class="cov8" title="40">{
        return utf8.RuneCountInString(str)
}</span>

// WordCount returns number of words in a string.
//
// Word is defined as a locale dependent string containing alphabetic characters,
// which may also contain but not start with `'` and `-` characters.
func WordCount(str string) int <span class="cov4" title="7">{
        var r rune
        var size, n int

        inWord := false

        for len(str) &gt; 0 </span><span class="cov9" title="53">{
                r, size = utf8.DecodeRuneInString(str)

                switch </span>{
                case isAlphabet(r):<span class="cov8" title="33">
                        if !inWord </span><span class="cov5" title="9">{
                                inWord = true
                                n++
                        }</span>

                case inWord &amp;&amp; (r == '\'' || r == '-'):<span class="cov4" title="5"></span>
                        // Still in word.

                default:<span class="cov6" title="15">
                        inWord = false</span>
                }

                <span class="cov9" title="53">str = str[size:]</span>
        }

        <span class="cov4" title="7">return n</span>
}

// Width returns string width in monotype font.
// Multi-byte characters are usually twice the width of single byte characters.
//
// Algorithm comes from `mb_strwidth` in PHP.
// http://php.net/manual/en/function.mb-strwidth.php
func Width(str string) int <span class="cov3" title="3">{
        var r rune
        var size, n int

        for len(str) &gt; 0 </span><span class="cov7" title="24">{
                r, size = utf8.DecodeRuneInString(str)
                n += RuneWidth(r)
                str = str[size:]
        }</span>

        <span class="cov3" title="3">return n</span>
}

// RuneWidth returns character width in monotype font.
// Multi-byte characters are usually twice the width of single byte characters.
//
// Algorithm comes from `mb_strwidth` in PHP.
// http://php.net/manual/en/function.mb-strwidth.php
func RuneWidth(r rune) int <span class="cov10" title="84">{
        switch </span>{
        case r == utf8.RuneError || r &lt; '\x20':<span class="cov3" title="3">
                return 0</span>

        case '\x20' &lt;= r &amp;&amp; r &lt; '\u2000':<span class="cov9" title="73">
                return 1</span>

        case '\u2000' &lt;= r &amp;&amp; r &lt; '\uFF61':<span class="cov5" title="8">
                return 2</span>

        case '\uFF61' &lt;= r &amp;&amp; r &lt; '\uFFA0':<span class="cov0" title="0">
                return 1</span>

        case '\uFFA0' &lt;= r:<span class="cov0" title="0">
                return 2</span>
        }

        <span class="cov0" title="0">return 0</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Copyright 2015 Huan Du. All rights reserved.
// Licensed under the MIT license that can be found in the LICENSE file.

package xstrings

import (
        "strings"
        "unicode/utf8"
)

// ExpandTabs can expand tabs ('\t') rune in str to one or more spaces dpending on
// current column and tabSize.
// The column number is reset to zero after each newline ('\n') occurring in the str.
//
// ExpandTabs uses RuneWidth to decide rune's width.
// For example, CJK characters will be treated as two characters.
//
// If tabSize &lt;= 0, ExpandTabs panics with error.
//
// Samples:
//     ExpandTabs("a\tbc\tdef\tghij\tk", 4) =&gt; "a   bc  def ghij    k"
//     ExpandTabs("abcdefg\thij\nk\tl", 4)  =&gt; "abcdefg hij\nk   l"
//     ExpandTabs("z中\t文\tw", 4)           =&gt; "z中 文  w"
func ExpandTabs(str string, tabSize int) string <span class="cov5" title="8">{
        if tabSize &lt;= 0 </span><span class="cov2" title="2">{
                panic("tab size must be positive")</span>
        }

        <span class="cov4" title="6">var r rune
        var i, size, column, expand int

        output := new(strings.Builder)

        orig := str

        for len(str) &gt; 0 </span><span class="cov10" title="76">{
                r, size = utf8.DecodeRuneInString(str)

                if r == '\t' </span><span class="cov6" title="16">{
                        expand = tabSize - column%tabSize

                        if output == nil </span><span class="cov0" title="0">{
                                output = allocBuffer(orig, str)
                        }</span>

                        <span class="cov6" title="16">for i = 0; i &lt; expand; i++ </span><span class="cov7" title="29">{
                                output.WriteRune(' ')
                        }</span>

                        <span class="cov6" title="16">column += expand</span>
                } else<span class="cov9" title="60"> {
                        if r == '\n' </span><span class="cov3" title="3">{
                                column = 0
                        }</span> else<span class="cov9" title="57"> {
                                column += RuneWidth(r)
                        }</span>

                        <span class="cov9" title="60">if output != nil </span><span class="cov9" title="60">{
                                output.WriteRune(r)
                        }</span>
                }

                <span class="cov10" title="76">str = str[size:]</span>
        }

        <span class="cov4" title="6">if output == nil </span><span class="cov0" title="0">{
                return orig
        }</span>

        <span class="cov4" title="6">return output.String()</span>
}

// LeftJustify returns a string with pad string at right side if str's rune length is smaller than length.
// If str's rune length is larger than length, str itself will be returned.
//
// If pad is an empty string, str will be returned.
//
// Samples:
//     LeftJustify("hello", 4, " ")    =&gt; "hello"
//     LeftJustify("hello", 10, " ")   =&gt; "hello     "
//     LeftJustify("hello", 10, "123") =&gt; "hello12312"
func LeftJustify(str string, length int, pad string) string <span class="cov5" title="8">{
        l := Len(str)

        if l &gt;= length || pad == "" </span><span class="cov3" title="4">{
                return str
        }</span>

        <span class="cov3" title="4">remains := length - l
        padLen := Len(pad)

        output := new(strings.Builder)
        output.Grow(len(str) + (remains/padLen+1)*len(pad))
        output.WriteString(str)
        writePadString(output, pad, padLen, remains)
        return output.String()</span>
}

// RightJustify returns a string with pad string at left side if str's rune length is smaller than length.
// If str's rune length is larger than length, str itself will be returned.
//
// If pad is an empty string, str will be returned.
//
// Samples:
//     RightJustify("hello", 4, " ")    =&gt; "hello"
//     RightJustify("hello", 10, " ")   =&gt; "     hello"
//     RightJustify("hello", 10, "123") =&gt; "12312hello"
func RightJustify(str string, length int, pad string) string <span class="cov5" title="8">{
        l := Len(str)

        if l &gt;= length || pad == "" </span><span class="cov3" title="4">{
                return str
        }</span>

        <span class="cov3" title="4">remains := length - l
        padLen := Len(pad)

        output := new(strings.Builder)
        output.Grow(len(str) + (remains/padLen+1)*len(pad))
        writePadString(output, pad, padLen, remains)
        output.WriteString(str)
        return output.String()</span>
}

// Center returns a string with pad string at both side if str's rune length is smaller than length.
// If str's rune length is larger than length, str itself will be returned.
//
// If pad is an empty string, str will be returned.
//
// Samples:
//     Center("hello", 4, " ")    =&gt; "hello"
//     Center("hello", 10, " ")   =&gt; "  hello   "
//     Center("hello", 10, "123") =&gt; "12hello123"
func Center(str string, length int, pad string) string <span class="cov5" title="8">{
        l := Len(str)

        if l &gt;= length || pad == "" </span><span class="cov3" title="4">{
                return str
        }</span>

        <span class="cov3" title="4">remains := length - l
        padLen := Len(pad)

        output := new(strings.Builder)
        output.Grow(len(str) + (remains/padLen+1)*len(pad))
        writePadString(output, pad, padLen, remains/2)
        output.WriteString(str)
        writePadString(output, pad, padLen, (remains+1)/2)
        return output.String()</span>
}

func writePadString(output *strings.Builder, pad string, padLen, remains int) <span class="cov6" title="16">{
        var r rune
        var size int

        repeats := remains / padLen

        for i := 0; i &lt; repeats; i++ </span><span class="cov7" title="27">{
                output.WriteString(pad)
        }</span>

        <span class="cov6" title="16">remains = remains % padLen

        if remains != 0 </span><span class="cov4" title="6">{
                for i := 0; i &lt; remains; i++ </span><span class="cov5" title="9">{
                        r, size = utf8.DecodeRuneInString(pad)
                        output.WriteRune(r)
                        pad = pad[size:]
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Copyright 2015 Huan Du. All rights reserved.
// Licensed under the MIT license that can be found in the LICENSE file.

package xstrings

import (
        "strings"
        "unicode"
        "unicode/utf8"
)

// Translate str with the characters defined in from replaced by characters defined in to.
//
// From and to are patterns representing a set of characters. Pattern is defined as following.
//
//     * Special characters
//       * '-' means a range of runes, e.g.
//         * "a-z" means all characters from 'a' to 'z' inclusive;
//         * "z-a" means all characters from 'z' to 'a' inclusive.
//       * '^' as first character means a set of all runes excepted listed, e.g.
//         * "^a-z" means all characters except 'a' to 'z' inclusive.
//       * '\' escapes special characters.
//     * Normal character represents itself, e.g. "abc" is a set including 'a', 'b' and 'c'.
//
// Translate will try to find a 1:1 mapping from from to to.
// If to is smaller than from, last rune in to will be used to map "out of range" characters in from.
//
// Note that '^' only works in the from pattern. It will be considered as a normal character in the to pattern.
//
// If the to pattern is an empty string, Translate works exactly the same as Delete.
//
// Samples:
//     Translate("hello", "aeiou", "12345")    =&gt; "h2ll4"
//     Translate("hello", "a-z", "A-Z")        =&gt; "HELLO"
//     Translate("hello", "z-a", "a-z")        =&gt; "svool"
//     Translate("hello", "aeiou", "*")        =&gt; "h*ll*"
//     Translate("hello", "^l", "*")           =&gt; "**ll*"
//     Translate("hello ^ world", `\^lo`, "*") =&gt; "he*** * w*r*d"
func Translate(str, from, to string) string <span class="cov6" title="21">{
        tr := NewTranslator(from, to)
        return tr.Translate(str)
}</span>

// Delete runes in str matching the pattern.
// Pattern is defined in Translate function.
//
// Samples:
//     Delete("hello", "aeiou") =&gt; "hll"
//     Delete("hello", "a-k")   =&gt; "llo"
//     Delete("hello", "^a-k")  =&gt; "he"
func Delete(str, pattern string) string <span class="cov3" title="4">{
        tr := NewTranslator(pattern, "")
        return tr.Translate(str)
}</span>

// Count how many runes in str match the pattern.
// Pattern is defined in Translate function.
//
// Samples:
//     Count("hello", "aeiou") =&gt; 3
//     Count("hello", "a-k")   =&gt; 3
//     Count("hello", "^a-k")  =&gt; 2
func Count(str, pattern string) int <span class="cov3" title="4">{
        if pattern == "" || str == "" </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov3" title="4">var r rune
        var size int
        var matched bool

        tr := NewTranslator(pattern, "")
        cnt := 0

        for len(str) &gt; 0 </span><span class="cov6" title="21">{
                r, size = utf8.DecodeRuneInString(str)
                str = str[size:]

                if _, matched = tr.TranslateRune(r); matched </span><span class="cov4" title="10">{
                        cnt++
                }</span>
        }

        <span class="cov3" title="4">return cnt</span>
}

// Squeeze deletes adjacent repeated runes in str.
// If pattern is not empty, only runes matching the pattern will be squeezed.
//
// Samples:
//     Squeeze("hello", "")             =&gt; "helo"
//     Squeeze("hello", "m-z")          =&gt; "hello"
//     Squeeze("hello   world", " ")    =&gt; "hello world"
func Squeeze(str, pattern string) string <span class="cov4" title="10">{
        var last, r rune
        var size int
        var skipSqueeze, matched bool
        var tr *Translator
        var output *strings.Builder

        orig := str
        last = -1

        if len(pattern) &gt; 0 </span><span class="cov4" title="7">{
                tr = NewTranslator(pattern, "")
        }</span>

        <span class="cov4" title="10">for len(str) &gt; 0 </span><span class="cov8" title="94">{
                r, size = utf8.DecodeRuneInString(str)

                // Need to squeeze the str.
                if last == r &amp;&amp; !skipSqueeze </span><span class="cov6" title="33">{
                        if tr != nil </span><span class="cov6" title="23">{
                                if _, matched = tr.TranslateRune(r); !matched </span><span class="cov4" title="7">{
                                        skipSqueeze = true
                                }</span>
                        }

                        <span class="cov6" title="33">if output == nil </span><span class="cov4" title="10">{
                                output = allocBuffer(orig, str)
                        }</span>

                        <span class="cov6" title="33">if skipSqueeze </span><span class="cov4" title="7">{
                                output.WriteRune(r)
                        }</span>
                } else<span class="cov7" title="61"> {
                        if output != nil </span><span class="cov6" title="36">{
                                output.WriteRune(r)
                        }</span>

                        <span class="cov7" title="61">last = r
                        skipSqueeze = false</span>
                }

                <span class="cov8" title="94">str = str[size:]</span>
        }

        <span class="cov4" title="10">if output == nil </span><span class="cov0" title="0">{
                return orig
        }</span>

        <span class="cov4" title="10">return output.String()</span>
}

type runeRangeMap struct {
        FromLo rune // Lower bound of range map.
        FromHi rune // An inclusive higher bound of range map.
        ToLo   rune
        ToHi   rune
}

type runeDict struct {
        Dict [unicode.MaxASCII + 1]rune
}

type runeMap map[rune]rune

// Translator can translate string with pre-compiled from and to patterns.
// If a from/to pattern pair needs to be used more than once, it's recommended
// to create a Translator and reuse it.
type Translator struct {
        quickDict  *runeDict       // A quick dictionary to look up rune by index. Only available for latin runes.
        runeMap    runeMap         // Rune map for translation.
        ranges     []*runeRangeMap // Ranges of runes.
        mappedRune rune            // If mappedRune &gt;= 0, all matched runes are translated to the mappedRune.
        reverted   bool            // If to pattern is empty, all matched characters will be deleted.
        hasPattern bool
}

// NewTranslator creates new Translator through a from/to pattern pair.
func NewTranslator(from, to string) *Translator <span class="cov6" title="36">{
        tr := &amp;Translator{}

        if from == "" </span><span class="cov0" title="0">{
                return tr
        }</span>

        <span class="cov6" title="36">reverted := from[0] == '^'
        deletion := len(to) == 0

        if reverted </span><span class="cov4" title="8">{
                from = from[1:]
        }</span>

        <span class="cov6" title="36">var fromStart, fromEnd, fromRangeStep rune
        var toStart, toEnd, toRangeStep rune
        var fromRangeSize, toRangeSize rune
        var singleRunes []rune

        // Update the to rune range.
        updateRange := func() </span><span class="cov8" title="75">{
                // No more rune to read in the to rune pattern.
                if toEnd == utf8.RuneError </span><span class="cov7" title="45">{
                        return
                }</span>

                <span class="cov6" title="30">if toRangeStep == 0 </span><span class="cov5" title="20">{
                        to, toStart, toEnd, toRangeStep = nextRuneRange(to, toEnd)
                        return
                }</span>

                // Current range is not empty. Consume 1 rune from start.
                <span class="cov4" title="10">if toStart != toEnd </span><span class="cov0" title="0">{
                        toStart += toRangeStep
                        return
                }</span>

                // No more rune. Repeat the last rune.
                <span class="cov4" title="10">if to == "" </span><span class="cov3" title="6">{
                        toEnd = utf8.RuneError
                        return
                }</span>

                // Both start and end are used. Read two more runes from the to pattern.
                <span class="cov3" title="4">to, toStart, toEnd, toRangeStep = nextRuneRange(to, utf8.RuneError)</span>
        }

        <span class="cov6" title="36">if deletion </span><span class="cov5" title="16">{
                toStart = utf8.RuneError
                toEnd = utf8.RuneError
        }</span> else<span class="cov5" title="20"> {
                // If from pattern is reverted, only the last rune in the to pattern will be used.
                if reverted </span><span class="cov3" title="4">{
                        var size int

                        for len(to) &gt; 0 </span><span class="cov4" title="9">{
                                toStart, size = utf8.DecodeRuneInString(to)
                                to = to[size:]
                        }</span>

                        <span class="cov3" title="4">toEnd = utf8.RuneError</span>
                } else<span class="cov5" title="16"> {
                        to, toStart, toEnd, toRangeStep = nextRuneRange(to, utf8.RuneError)
                }</span>
        }

        <span class="cov6" title="36">fromEnd = utf8.RuneError

        for len(from) &gt; 0 </span><span class="cov8" title="80">{
                from, fromStart, fromEnd, fromRangeStep = nextRuneRange(from, fromEnd)

                // fromStart is a single character. Just map it with a rune in the to pattern.
                if fromRangeStep == 0 </span><span class="cov7" title="62">{
                        singleRunes = tr.addRune(fromStart, toStart, singleRunes)
                        updateRange()
                        continue</span>
                }

                <span class="cov5" title="18">for toEnd != utf8.RuneError &amp;&amp; fromStart != fromEnd </span><span class="cov4" title="11">{
                        // If mapped rune is a single character instead of a range, simply shift first
                        // rune in the range.
                        if toRangeStep == 0 </span><span class="cov1" title="1">{
                                singleRunes = tr.addRune(fromStart, toStart, singleRunes)
                                updateRange()
                                fromStart += fromRangeStep
                                continue</span>
                        }

                        <span class="cov4" title="10">fromRangeSize = (fromEnd - fromStart) * fromRangeStep
                        toRangeSize = (toEnd - toStart) * toRangeStep

                        // Not enough runes in the to pattern. Need to read more.
                        if fromRangeSize &gt; toRangeSize </span><span class="cov3" title="4">{
                                fromStart, toStart = tr.addRuneRange(fromStart, fromStart+toRangeSize*fromRangeStep, toStart, toEnd, singleRunes)
                                fromStart += fromRangeStep
                                updateRange()

                                // Edge case: If fromRangeSize == toRangeSize + 1, the last fromStart value needs be considered
                                // as a single rune.
                                if fromStart == fromEnd </span><span class="cov2" title="2">{
                                        singleRunes = tr.addRune(fromStart, toStart, singleRunes)
                                        updateRange()
                                }</span>

                                <span class="cov3" title="4">continue</span>
                        }

                        <span class="cov3" title="6">fromStart, toStart = tr.addRuneRange(fromStart, fromEnd, toStart, toStart+fromRangeSize*toRangeStep, singleRunes)
                        updateRange()
                        break</span>
                }

                <span class="cov5" title="18">if fromStart == fromEnd </span><span class="cov4" title="8">{
                        fromEnd = utf8.RuneError
                        continue</span>
                }

                <span class="cov4" title="10">_, toStart = tr.addRuneRange(fromStart, fromEnd, toStart, toStart, singleRunes)
                fromEnd = utf8.RuneError</span>
        }

        <span class="cov6" title="36">if fromEnd != utf8.RuneError </span><span class="cov4" title="11">{
                tr.addRune(fromEnd, toStart, singleRunes)
        }</span>

        <span class="cov6" title="36">tr.reverted = reverted
        tr.mappedRune = -1
        tr.hasPattern = true

        // Translate RuneError only if in deletion or reverted mode.
        if deletion || reverted </span><span class="cov5" title="20">{
                tr.mappedRune = toStart
        }</span>

        <span class="cov6" title="36">return tr</span>
}

func (tr *Translator) addRune(from, to rune, singleRunes []rune) []rune <span class="cov8" title="76">{
        if from &lt;= unicode.MaxASCII </span><span class="cov7" title="49">{
                if tr.quickDict == nil </span><span class="cov5" title="18">{
                        tr.quickDict = &amp;runeDict{}
                }</span>

                <span class="cov7" title="49">tr.quickDict.Dict[from] = to</span>
        } else<span class="cov6" title="27"> {
                if tr.runeMap == nil </span><span class="cov4" title="7">{
                        tr.runeMap = make(runeMap)
                }</span>

                <span class="cov6" title="27">tr.runeMap[from] = to</span>
        }

        <span class="cov8" title="76">singleRunes = append(singleRunes, from)
        return singleRunes</span>
}

func (tr *Translator) addRuneRange(fromLo, fromHi, toLo, toHi rune, singleRunes []rune) (rune, rune) <span class="cov5" title="20">{
        var r rune
        var rrm *runeRangeMap

        if fromLo &lt; fromHi </span><span class="cov5" title="19">{
                rrm = &amp;runeRangeMap{
                        FromLo: fromLo,
                        FromHi: fromHi,
                        ToLo:   toLo,
                        ToHi:   toHi,
                }
        }</span> else<span class="cov1" title="1"> {
                rrm = &amp;runeRangeMap{
                        FromLo: fromHi,
                        FromHi: fromLo,
                        ToLo:   toHi,
                        ToHi:   toLo,
                }
        }</span>

        // If there is any single rune conflicts with this rune range, clear single rune record.
        <span class="cov5" title="20">for _, r = range singleRunes </span><span class="cov5" title="17">{
                if rrm.FromLo &lt;= r &amp;&amp; r &lt;= rrm.FromHi </span><span class="cov4" title="8">{
                        if r &lt;= unicode.MaxASCII </span><span class="cov4" title="8">{
                                tr.quickDict.Dict[r] = 0
                        }</span> else<span class="cov0" title="0"> {
                                delete(tr.runeMap, r)
                        }</span>
                }
        }

        <span class="cov5" title="20">tr.ranges = append(tr.ranges, rrm)
        return fromHi, toHi</span>
}

func nextRuneRange(str string, last rune) (remaining string, start, end rune, rangeStep rune) <span class="cov8" title="120">{
        var r rune
        var size int

        remaining = str
        escaping := false
        isRange := false

        for len(remaining) &gt; 0 </span><span class="cov9" title="206">{
                r, size = utf8.DecodeRuneInString(remaining)
                remaining = remaining[size:]

                // Parse special characters.
                if !escaping </span><span class="cov9" title="204">{
                        if r == '\\' </span><span class="cov2" title="2">{
                                escaping = true
                                continue</span>
                        }

                        <span class="cov9" title="202">if r == '-' </span><span class="cov7" title="45">{
                                // Ignore slash at beginning of string.
                                if last == utf8.RuneError </span><span class="cov4" title="8">{
                                        continue</span>
                                }

                                <span class="cov6" title="37">start = last
                                isRange = true
                                continue</span>
                        }
                }

                <span class="cov9" title="159">escaping = false

                if last != utf8.RuneError </span><span class="cov8" title="99">{
                        // This is a range which start and end are the same.
                        // Considier it as a normal character.
                        if isRange &amp;&amp; last == r </span><span class="cov0" title="0">{
                                isRange = false
                                continue</span>
                        }

                        <span class="cov8" title="99">start = last
                        end = r

                        if isRange </span><span class="cov6" title="28">{
                                if start &lt; end </span><span class="cov6" title="27">{
                                        rangeStep = 1
                                }</span> else<span class="cov1" title="1"> {
                                        rangeStep = -1
                                }</span>
                        }

                        <span class="cov8" title="99">return</span>
                }

                <span class="cov7" title="60">last = r</span>
        }

        <span class="cov6" title="21">start = last
        end = utf8.RuneError
        return</span>
}

// Translate str with a from/to pattern pair.
//
// See comment in Translate function for usage and samples.
func (tr *Translator) Translate(str string) string <span class="cov6" title="25">{
        if !tr.hasPattern || str == "" </span><span class="cov0" title="0">{
                return str
        }</span>

        <span class="cov6" title="25">var r rune
        var size int
        var needTr bool

        orig := str

        var output *strings.Builder

        for len(str) &gt; 0 </span><span class="cov9" title="185">{
                r, size = utf8.DecodeRuneInString(str)
                r, needTr = tr.TranslateRune(r)

                if needTr &amp;&amp; output == nil </span><span class="cov6" title="24">{
                        output = allocBuffer(orig, str)
                }</span>

                <span class="cov9" title="185">if r != utf8.RuneError &amp;&amp; output != nil </span><span class="cov9" title="150">{
                        output.WriteRune(r)
                }</span>

                <span class="cov9" title="185">str = str[size:]</span>
        }

        // No character is translated.
        <span class="cov6" title="25">if output == nil </span><span class="cov1" title="1">{
                return orig
        }</span>

        <span class="cov6" title="24">return output.String()</span>
}

// TranslateRune return translated rune and true if r matches the from pattern.
// If r doesn't match the pattern, original r is returned and translated is false.
func (tr *Translator) TranslateRune(r rune) (result rune, translated bool) <span class="cov10" title="229">{
        switch </span>{
        case tr.quickDict != nil:<span class="cov9" title="145">
                if r &lt;= unicode.MaxASCII </span><span class="cov9" title="144">{
                        result = tr.quickDict.Dict[r]

                        if result != 0 </span><span class="cov7" title="41">{
                                translated = true

                                if tr.mappedRune &gt;= 0 </span><span class="cov6" title="21">{
                                        result = tr.mappedRune
                                }</span>

                                <span class="cov7" title="41">break</span>
                        }
                }

                <span class="cov8" title="104">fallthrough</span>

        case tr.runeMap != nil:<span class="cov9" title="144">
                var ok bool

                if result, ok = tr.runeMap[r]; ok </span><span class="cov5" title="17">{
                        translated = true

                        if tr.mappedRune &gt;= 0 </span><span class="cov5" title="13">{
                                result = tr.mappedRune
                        }</span>

                        <span class="cov5" title="17">break</span>
                }

                <span class="cov9" title="127">fallthrough</span>

        default:<span class="cov9" title="171">
                var rrm *runeRangeMap
                ranges := tr.ranges

                for i := len(ranges) - 1; i &gt;= 0; i-- </span><span class="cov9" title="157">{
                        rrm = ranges[i]

                        if rrm.FromLo &lt;= r &amp;&amp; r &lt;= rrm.FromHi </span><span class="cov7" title="59">{
                                translated = true

                                if tr.mappedRune &gt;= 0 </span><span class="cov4" title="9">{
                                        result = tr.mappedRune
                                        break</span>
                                }

                                <span class="cov7" title="50">if rrm.ToLo &lt; rrm.ToHi </span><span class="cov7" title="39">{
                                        result = rrm.ToLo + r - rrm.FromLo
                                }</span> else<span class="cov4" title="11"> if rrm.ToLo &gt; rrm.ToHi </span><span class="cov3" title="5">{
                                        // ToHi can be smaller than ToLo if range is from higher to lower.
                                        result = rrm.ToLo - r + rrm.FromLo
                                }</span> else<span class="cov3" title="6"> {
                                        result = rrm.ToLo
                                }</span>

                                <span class="cov7" title="50">break</span>
                        }
                }
        }

        <span class="cov10" title="229">if tr.reverted </span><span class="cov6" title="34">{
                if !translated </span><span class="cov6" title="22">{
                        result = tr.mappedRune
                }</span>

                <span class="cov6" title="34">translated = !translated</span>
        }

        <span class="cov10" title="229">if !translated </span><span class="cov8" title="102">{
                result = r
        }</span>

        <span class="cov10" title="229">return</span>
}

// HasPattern returns true if Translator has one pattern at least.
func (tr *Translator) HasPattern() bool <span class="cov0" title="0">{
        return tr.hasPattern
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
